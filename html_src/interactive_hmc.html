<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive HMC Demo - Hamiltonian Monte Carlo | Jules Perret</title>
  <meta name="description" content="Interactive visualization of the Hamiltonian Monte Carlo (HMC) algorithm" />

  <!-- MathJax for LaTeX rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      }
    };
  </script>

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #fafafa;
      color: #1a1a1a;
      margin: 0;
      padding: 0;
      line-height: 1.6;
    }

    /* Jekyll-compatible header navigation */
    .site-header {
      border-top: 5px solid #424242;
      border-bottom: 1px solid #e8e8e8;
      min-height: 55.95px;
      position: relative;
      background-color: white;
    }

    .site-header .wrapper {
      max-width: calc(1200px - (30px * 2));
      margin-right: auto;
      margin-left: auto;
      padding-right: 30px;
      padding-left: 30px;
    }

    .site-title {
      font-size: 26px;
      font-weight: 300;
      line-height: 54px;
      letter-spacing: -1px;
      margin-bottom: 0;
      float: left;
      text-decoration: none;
      color: #424242;
    }

    .site-title:hover {
      text-decoration: none;
      color: #111;
    }

    .site-nav {
      float: right;
      line-height: 54px;
    }

    .site-nav .nav-trigger {
      display: none;
    }

    .site-nav .menu-icon {
      display: none;
    }

    .site-nav .page-link {
      color: #111;
      line-height: 1.5;
      text-decoration: none;
      margin-left: 20px;
    }

    .site-nav .page-link:hover {
      text-decoration: underline;
    }

    .site-nav .page-link.active {
      font-weight: 600;
    }

    @media screen and (max-width: 600px) {
      .site-nav {
        position: absolute;
        top: 9px;
        right: 15px;
        background-color: white;
        border: 1px solid #e8e8e8;
        border-radius: 5px;
        text-align: right;
      }

      .site-nav label[for="nav-trigger"] {
        display: block;
        float: right;
        width: 36px;
        height: 36px;
        z-index: 2;
        cursor: pointer;
      }

      .site-nav .menu-icon {
        display: block;
        float: right;
        width: 36px;
        height: 26px;
        line-height: 0;
        padding-top: 10px;
        text-align: center;
      }

      .site-nav .menu-icon > svg {
        fill: #424242;
      }

      .site-nav input ~ .trigger {
        clear: both;
        display: none;
      }

      .site-nav input:checked ~ .trigger {
        display: block;
        padding-bottom: 5px;
      }

      .site-nav .page-link {
        display: block;
        padding: 5px 10px;
        margin-left: 20px;
      }
    }

    .page-content {
      padding: 0;
    }

    .wrapper {
      max-width: calc(1200px - (30px * 2));
      margin-right: auto;
      margin-left: auto;
      padding-right: 30px;
      padding-left: 30px;
    }

    .page-heading {
      font-size: 2rem;
      font-weight: 600;
      margin: 2rem 0 1rem;
      color: #1a1a1a;
    }

    .page-subtitle {
      font-size: 1.1rem;
      color: #4a5568;
      margin-bottom: 2rem;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }
    

    .section {
      background: white;
      border-radius: 8px;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }

    .section-title {
      font-size: 1.4rem;
      font-weight: 600;
      margin: 0 0 1.5rem 0;
      color: #1a1a1a;
      border-bottom: 2px solid #111827;
      padding-bottom: 0.5rem;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .control-group label {
      font-weight: 500;
      font-size: 0.9rem;
      color: #4a5568;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .control-value {
      font-weight: 600;
      color: #111827;
      font-size: 1rem;
    }

    input[type=range] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #e2e8f0;
      outline: none;
      -webkit-appearance: none;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #111827;
      cursor: pointer;
      transition: all 0.2s;
    }

    input[type=range]::-webkit-slider-thumb:hover {
      background: #374151;
      transform: scale(1.1);
    }

    select {
      padding: 0.5rem;
      border: 1px solid #cbd5e0;
      border-radius: 4px;
      font-size: 0.9rem;
      background: white;
      cursor: pointer;
    }

    .button-group {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    button {
      background: #111827;
      color: white;
      border: none;
      padding: 0.6rem 1.3rem;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    button:hover {
      background: #374151;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: #4b5563;
    }

    button.secondary:hover {
      background: #6b7280;
    }

    button.tertiary {
      background: #9ca3af;
    }

    button.tertiary:hover {
      background: #6b7280;
    }

    .visualization-grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 2rem;
      margin-bottom: 2rem;
    }

    .canvas-container {
      position: relative;
    }

    .canvas-label {
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 0.75rem;
      color: #2d3748;
    }

    canvas {
      border: 1px solid #e2e8f0;
      background: white;
      border-radius: 4px;
      display: block;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }

    .marginal-plots {
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .marginal-plot {
      display: flex;
      flex-direction: column;
    }

    .stats-panel {
      background: linear-gradient(135deg, #f6f8fc 0%, #eef2f7 100%);
      border-radius: 8px;
      padding: 1.5rem;
      border: 1px solid #e2e8f0;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-top: 1rem;
    }

    .stat-item {
      background: white;
      padding: 0.75rem;
      border-radius: 4px;
      border-left: 3px solid #111827;
    }

    .stat-label {
      font-size: 0.8rem;
      color: #718096;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2d3748;
      margin-top: 0.25rem;
    }

    .algorithm-box {
      background: #f7fafc;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      padding: 1.5rem;
      margin-top: 1rem;
      overflow-x: auto;
    }

    .algorithm-box ol {
      margin: 0.5rem 0 0 0;
      padding-left: 1.5rem;
    }

    .algorithm-box li {
      margin: 0.5rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.95rem;
    }

    .step-info {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      padding: 1.25rem;
      font-size: 0.9rem;
      margin-top: 1rem;
    }

    .step-info strong {
      color: #111827;
      font-size: 0.95rem;
    }

    .status-accepted {
      color: #38a169;
      font-weight: 600;
    }

    .status-rejected {
      color: #e53e3e;
      font-weight: 600;
    }

    .info-note {
      background: #fef5e7;
      border-left: 4px solid #f39c12;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    @media (max-width: 768px) {
      .visualization-grid {
        grid-template-columns: 1fr;
      }
      
      .controls-grid {
        grid-template-columns: 1fr;
      }

      .section {
        padding: 1.5rem 1rem;
      }

      .container {
        padding: 1rem;
      }

      .header {
        padding: 1.5rem 1rem;
      }

      .header h1 {
        font-size: 1.5rem;
      }

      .header p {
        font-size: 0.9rem;
      }

      canvas#posterior {
        width: 100% !important;
        height: auto !important;
      }

      .stats-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>

<header class="site-header">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Jules Perret</a>
    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
          </svg>
        </span>
      </label>
      <div class="trigger">
        <a class="page-link" href="/about.html">Curriculum Vitae</a>
        <a class="page-link" href="/publications.html">Publications</a>
        <a class="page-link" href="/research.html">Research</a>
        <a class="page-link" href="/mcmc.html">MCMC Demo</a>
        <a class="page-link active" href="/hmc.html">HMC Demo</a>
      </div>
    </nav>
  </div>
</header>

<main class="page-content" aria-label="Content">
  <div class="wrapper">
    <h1 class="page-heading">Hamiltonian Monte Carlo (HMC)</h1>
    <p class="page-subtitle">
      Interactive visualization of gradient-based MCMC sampling from 2D posterior distributions<br>
      <span style="font-size: 0.9rem; color: #718096;">Part 2 of the MCMC Samplers Series | See also: <a href="/mcmc.html" style="color: #667eea;">Metropolis–Hastings</a></span>
    </p>
  </div>
</main>

<div class="container">

  <!-- INTRODUCTION -->
  <div class="section">
    <h2 class="section-title">Introduction to Hamiltonian Monte Carlo</h2>
    <p>
      <strong>Hamiltonian Monte Carlo (HMC)</strong> is an advanced MCMC algorithm that uses gradient information 
      and concepts from Hamiltonian dynamics to generate efficient proposals. Unlike random-walk methods 
      (like Metropolis–Hastings), HMC proposes distant states while maintaining high acceptance rates by 
      following the natural geometry of the posterior distribution.
    </p>
    <p>
      HMC addresses the two main challenges of random-walk MCMC: <strong>random walk behavior</strong> 
      (slow, diffusive exploration) and <strong>sensitivity to correlations</strong> (inefficient axis-aligned 
      proposals). By simulating Hamiltonian dynamics, HMC proposes states that move coherently along 
      the posterior's contours, dramatically improving efficiency especially in high dimensions.
    </p>
    
    <div class="algorithm-box" style="margin-top: 1.5rem;">
      <strong>Why HMC?</strong>
      <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
        <li><strong>Efficient exploration:</strong> Uses gradient information to propose distant states with high acceptance probability</li>
        <li><strong>Reduced autocorrelation:</strong> Makes large, coherent moves through parameter space instead of small random steps</li>
        <li><strong>Handles correlations:</strong> Naturally adapts to the posterior geometry, efficient even with strong correlations</li>
        <li><strong>Scalable:</strong> Performance often improves (relatively) as dimensionality increases, unlike random-walk methods</li>
        <li><strong>Industry standard:</strong> Powers modern Bayesian software like Stan, PyMC, and NumPyro</li>
      </ul>
    </div>

    <div class="info-note" style="margin-top: 1.5rem;">
      <strong>The Key Insight:</strong> HMC augments the parameter space with auxiliary momentum variables and 
      simulates Hamiltonian dynamics. This transforms the sampling problem into a physics simulation where 
      a particle explores the posterior by conserving total energy—naturally spending more time in 
      high-probability regions while making efficient long-distance moves.
    </div>
  </div>

  <!-- ALGORITHM DESCRIPTION -->
  <div class="section">
    <h2 class="section-title">The Hamiltonian Monte Carlo Algorithm</h2>
    <p>
      <strong>HMC</strong> was introduced by Duane et al. (1987) for lattice field theory and popularized 
      for statistics by Neal (1996, 2011). The algorithm augments the parameter vector \(\mathbf{q}\) 
      (position) with a momentum vector \(\mathbf{p}\), defining a Hamiltonian system.
    </p>

    <div class="algorithm-box">
      <strong>The Hamiltonian:</strong>
      <p style="margin: 0.75rem 0;">
        The total energy of the system combines potential energy (negative log posterior) and kinetic energy:
      </p>
      $$H(\mathbf{q}, \mathbf{p}) = U(\mathbf{q}) + K(\mathbf{p})$$
      <p style="margin: 0.5rem 0;">
        where:
      </p>
      <ul style="margin: 0; padding-left: 1.5rem;">
        <li>\(U(\mathbf{q}) = -\log \pi(\mathbf{q})\) is the potential energy (negative log target density)</li>
        <li>\(K(\mathbf{p}) = \frac{1}{2}\mathbf{p}^T M^{-1} \mathbf{p}\) is the kinetic energy (mass matrix \(M\))</li>
      </ul>
      <p style="margin: 0.75rem 0 0 0;">
        In this demo, we use \(M = I\) (identity matrix), so \(K(\mathbf{p}) = \frac{1}{2}\sum_i p_i^2\).
      </p>
    </div>
    
    <div class="algorithm-box" style="margin-top: 1.5rem;">
      <strong>HMC Algorithm Steps:</strong>
      <ol style="margin: 0.5rem 0 0.5rem 0; padding-left: 1.5rem;">
        <li style="margin: 0.75rem 0;">
          <strong>Sample momentum:</strong> Draw \(\mathbf{p} \sim \mathcal{N}(0, M)\)
        </li>
        <li style="margin: 0.75rem 0;">
          <strong>Simulate Hamiltonian dynamics:</strong> Starting from \((\mathbf{q}, \mathbf{p})\), integrate 
          Hamilton's equations for \(L\) steps of size \(\epsilon\):
          $$\begin{aligned}
          \frac{d\mathbf{q}}{dt} &= \frac{\partial H}{\partial \mathbf{p}} = M^{-1}\mathbf{p}\\
          \frac{d\mathbf{p}}{dt} &= -\frac{\partial H}{\partial \mathbf{q}} = -\nabla U(\mathbf{q})
          \end{aligned}$$
          We use the <strong>leapfrog integrator</strong> (symplectic, reversible):
          <div style="margin: 0.75rem 0 0 1.5rem; font-family: 'Courier New', monospace; font-size: 0.9rem;">
            \(\mathbf{p} \leftarrow \mathbf{p} - \frac{\epsilon}{2}\nabla U(\mathbf{q})\)<br>
            for \(i = 1\) to \(L\):<br>
            &nbsp;&nbsp;\(\mathbf{q} \leftarrow \mathbf{q} + \epsilon M^{-1}\mathbf{p}\)<br>
            &nbsp;&nbsp;\(\mathbf{p} \leftarrow \mathbf{p} - \epsilon \nabla U(\mathbf{q})\) &nbsp;(except last step: \(\epsilon/2\))
          </div>
        </li>
        <li style="margin: 0.75rem 0;">
          <strong>Metropolis acceptance:</strong> Propose \((\mathbf{q}^*, \mathbf{p}^*)\) from dynamics. Accept with probability:
          $$\alpha = \min\left(1, \exp(H(\mathbf{q}, \mathbf{p}) - H(\mathbf{q}^*, \mathbf{p}^*))\right)$$
          Due to numerical errors, \(H\) is not perfectly conserved, but acceptance corrects for this.
        </li>
        <li style="margin: 0.75rem 0;">
          <strong>Return position:</strong> If accepted, set \(\mathbf{q}_{t+1} = \mathbf{q}^*\); else \(\mathbf{q}_{t+1} = \mathbf{q}_t\)
        </li>
      </ol>
    </div>

    <div class="info-note" style="margin-top: 1.5rem;">
      <strong>Why it works:</strong> The leapfrog integrator approximately conserves the Hamiltonian \(H\). 
      Regions with low \(U(\mathbf{q})\) (high probability) correspond to low potential energy, where the 
      particle naturally spends more time—just like a ball rolling in a valley. The momentum carries the 
      particle across low-probability regions, enabling efficient exploration without getting trapped.
    </div>
  </div>

  <!-- TARGET DISTRIBUTIONS -->
  <div class="section">
    <h2 class="section-title">Target Distributions</h2>
    <p>
      This demonstration provides three target distributions ranging from simple to challenging, 
      illustrating different aspects of MCMC performance:
    </p>
    
    <div style="display: grid; grid-template-columns: 1fr; gap: 1.5rem; margin-top: 1rem;">
      <div class="algorithm-box">
        <strong>Bivariate Gaussian (Default)</strong>
        <p style="margin: 0.5rem 0;">
          A standard correlated 2D Gaussian with correlation coefficient \(\rho = 0.8\):
        </p>
        <div style="overflow-x: auto;">
          $$\pi(x_1, x_2) \propto \exp\left(-\frac{1}{2(1-\rho^2)}(x_1^2 - 2\rho x_1 x_2 + x_2^2)\right)$$
        </div>
        <p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #4a5568;">
          This distribution has elliptical contours aligned with the correlation structure. 
          With strong correlation (\(\rho = 0.8\)), random-walk proposals struggle because they explore 
          axis-by-axis when parameters should move together along the correlation direction.
        </p>
      </div>

      <div class="algorithm-box">
        <strong>Rosenbrock's Banana Distribution</strong>
        <p style="margin: 0.5rem 0;">
          A transformed Gaussian that creates a curved, banana-shaped density (Haario et al., 1999):
        </p>
        <div style="overflow-x: auto;">
          $$\pi(x_1, x_2) \propto \exp\left(-\frac{1}{200}(x_1^2 + 100(x_2 - x_1^2)^2)\right)$$
        </div>
        <p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #4a5568;">
          This distribution is strongly correlated along a curved manifold, making it difficult for 
          random-walk samplers to explore efficiently. The "banana" shape arises from the nonlinear 
          transformation \(x_2 - x_1^2\), creating regions where standard proposals are inefficient.
        </p>
      </div>
      
      <div class="algorithm-box">
        <strong>Neal's Funnel Distribution</strong>
        <p style="margin: 0.5rem 0;">
          A hierarchical model that exhibits strong scale variations (Neal, 2003):
        </p>
        <div style="overflow-x: auto;">
          $$\begin{aligned}
          x_1 &\sim \mathcal{N}(0, 3^2) \\
          x_2 \mid x_1 &\sim \mathcal{N}(0, \exp(x_1)^2)
          \end{aligned}$$
        </div>
        <p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #4a5568;">
          The joint density is \(\pi(x_1, x_2) \propto \exp(-x_1^2/18 - x_2^2/(2e^{2x_1}))\). 
          This creates a "funnel" where the scale of \(x_2\) depends exponentially on \(x_1\), 
          challenging for fixed-width proposals. Common in hierarchical Bayesian models with variance parameters.
        </p>
      </div>
    </div>
    
    <div class="info-note" style="margin-top: 1rem;">
      <strong>Why these distributions?</strong> The Gaussian provides a baseline to understand basic behavior. 
      Rosenbrock's banana and Neal's funnel are standard benchmarks in the MCMC literature—the banana tests 
      handling of strong nonlinear correlations, while the funnel tests adaptation to varying scales. 
      These challenges motivate advanced methods like HMC and adaptive MCMC.
    </div>
  </div>

  <!-- CONTROLS -->
  <div class="section">
    <h2 class="section-title">Simulation Controls</h2>
    <p>
      HMC has two key tuning parameters: the <strong>step size</strong> \(\epsilon\) (how large each 
      leapfrog step is) and the <strong>number of steps</strong> \(L\) (how long the trajectory is). 
      The product \(L \times \epsilon\) determines the trajectory length.
    </p>
    
    <div class="controls-grid">
      <div class="control-group">
        <label>
          Step Size (\(\epsilon\))
          <span class="control-value" id="epsilonVal">0.10</span>
        </label>
        <input type="range" min="0.01" max="0.5" step="0.01" value="0.10" id="epsilon">
        <div style="font-size: 0.85rem; color: #4a5568; margin-top: 0.25rem;">
          Size of each leapfrog integration step. Smaller → more accurate, but slower.
        </div>
      </div>

      <div class="control-group">
        <label>
          Number of Steps (L)
          <span class="control-value" id="numStepsVal">20</span>
        </label>
        <input type="range" min="5" max="100" step="1" value="20" id="numSteps">
        <div style="font-size: 0.85rem; color: #4a5568; margin-top: 0.25rem;">
          Length of trajectory. More steps → longer proposals, but can overshoot.
        </div>
      </div>

      <div class="control-group">
        <label>
          Iteration Speed (ms)
          <span class="control-value" id="speedVal">60</span>
        </label>
        <input type="range" min="10" max="500" step="10" value="60" id="speed">
        <div style="font-size: 0.85rem; color: #4a5568; margin-top: 0.25rem;">
          Delay between iterations. Slower speeds help visualize trajectories.
        </div>
      </div>

      <div class="control-group">
        <label>
          Target Distribution
        </label>
        <select id="dist">
          <option value="gaussian">Bivariate Gaussian</option>
          <option value="banana">Rosenbrock's Banana</option>
          <option value="funnel">Neal's Funnel</option>
        </select>
        <div style="font-size: 0.85rem; color: #4a5568; margin-top: 0.25rem;">
          Same distributions as Metropolis–Hastings for direct comparison.
        </div>
      </div>
    </div>

    <div class="button-group">
      <button onclick="start()">▶ Start Sampling</button>
      <button class="secondary" onclick="singleStep()">→ Single Step</button>
      <button class="tertiary" onclick="reset()">⟲ Reset</button>
    </div>

    <div class="info-note" style="margin-top: 1.5rem;">
      <strong>Tuning advice:</strong> Optimal step size balances integration accuracy vs. efficiency. 
      Too large → high rejection due to numerical error. Too small → inefficient short proposals. 
      Aim for acceptance rates around 65-90% (much higher than MH's 23-40%!). Modern implementations 
      like NUTS (No-U-Turn Sampler) automatically tune these parameters.
    </div>
  </div>

  <!-- VISUALIZATION -->
  <div class="section">
    <h2 class="section-title">HMC Trajectory Visualization</h2>
    <p>
      The main plot shows the joint posterior \(\pi(q_1, q_2)\) with darker regions indicating higher probability. 
      Unlike random-walk methods, HMC trajectories follow curved paths determined by the gradient of the log posterior.
      <span style="color: #38a169; font-weight: 600;">Green points</span> indicate accepted proposals and 
      <span style="color: #ed8936; font-weight: 600;">orange points</span> indicate rejected proposals.
      The plot axes automatically adjust to each distribution's natural range.
    </p>
    
    <div class="visualization-grid">
      <!-- Main posterior plot -->
      <div class="canvas-container">
        <div class="canvas-label">Joint Posterior Distribution π(x₁, x₂)</div>
        <canvas id="posterior" width="650" height="650"></canvas>
        <p style="font-size: 0.85rem; color: #4a5568; margin-top: 0.5rem;">
          The chain should explore the high-density regions (darker areas) while maintaining enough 
          randomness to avoid getting trapped in any single location.
        </p>
      </div>

      <!-- Marginal plots -->
      <div class="marginal-plots">
        <div class="marginal-plot">
          <div class="canvas-label">Marginal Distribution of x₁</div>
          <canvas id="histX" width="300" height="280"></canvas>
          <p style="font-size: 0.85rem; color: #4a5568; margin-top: 0.5rem;">
            Histogram of \(x_1\) samples. Should converge to the true marginal \(\pi(x_1) = \int \pi(x_1, x_2) dx_2\).
          </p>
        </div>
        <div class="marginal-plot">
          <div class="canvas-label">Marginal Distribution of x₂</div>
          <canvas id="histY" width="300" height="280"></canvas>
          <p style="font-size: 0.85rem; color: #4a5568; margin-top: 0.5rem;">
            Histogram of \(x_2\) samples. With enough samples, this approximates the true marginal distribution.
          </p>
        </div>
      </div>
    </div>

    <!-- Current step info -->
    <div class="stats-panel">
      <strong>Current Iteration Details</strong>
      <div id="stepInfo" class="step-info">
        Click "Start Sampling" or "Single Step" to begin the MCMC algorithm.
      </div>
    </div>
  </div>

  <!-- TRACE PLOTS -->
  <div class="section">
    <h2 class="section-title">Chain Trace Plots</h2>
    <p>
      <strong>Trace plots</strong> show the evolution of each parameter value over iterations. They are essential 
      for diagnosing convergence and mixing of the MCMC chain.
    </p>
    
    <div class="algorithm-box" style="margin-bottom: 1.5rem;">
      <strong>What to look for in trace plots:</strong>
      <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
        <li><strong>Good mixing:</strong> The trace should look like "fuzzy caterpillar" - random fluctuations 
        around a stable mean with no obvious patterns or trends</li>
        <li><strong>Stationarity:</strong> The mean and variance should remain constant over time (after burn-in)</li>
        <li><strong>No trends:</strong> The trace shouldn't show long-term upward or downward trends</li>
        <li><strong>No getting stuck:</strong> The chain shouldn't remain at the same value for extended periods</li>
      </ul>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr; gap: 1.5rem;">
      <div>
        <div class="canvas-label">Trace Plot: x₁ Evolution</div>
        <canvas id="traceX" width="100%" height="200" style="width: 100%;"></canvas>
        <p style="font-size: 0.85rem; color: #4a5568; margin-top: 0.5rem;">
          Time series of \(x_1\) values. Rapid fluctuations indicate good exploration; long periods at similar 
          values suggest poor mixing.
        </p>
      </div>
      <div>
        <div class="canvas-label">Trace Plot: x₂ Evolution</div>
        <canvas id="traceY" width="100%" height="200" style="width: 100%;"></canvas>
        <p style="font-size: 0.85rem; color: #4a5568; margin-top: 0.5rem;">
          Time series of \(x_2\) values. Compare with \(x_1\) trace to check if both parameters mix at similar rates.
        </p>
      </div>
    </div>
  </div>

  <!-- DIAGNOSTICS -->
  <div class="section">
    <h2 class="section-title">Chain Diagnostics</h2>
    
    <h3 style="font-size: 1.1rem; font-weight: 600; margin: 0 0 1rem 0;">Autocorrelation Function (ACF)</h3>
    <p>
      The <strong>autocorrelation function</strong> measures the correlation between samples separated by 
      \(\tau\) iterations (the lag). For a well-mixing chain, the ACF should decay rapidly to zero.
    </p>
    
    <div class="algorithm-box" style="margin-bottom: 1.5rem;">
      <strong>Mathematical Definition:</strong>
      <p style="margin: 0.75rem 0;">
        For a chain \(\{x_t\}\) with sample mean \(\bar{x}\) and sample variance \(s^2\), the sample ACF at lag \(\tau\) is:
      </p>
      $$\hat{\rho}(\tau) = \frac{\sum_{t=1}^{n-\tau} (x_t - \bar{x})(x_{t+\tau} - \bar{x})}{\sum_{t=1}^{n} (x_t - \bar{x})^2}$$
      <p style="margin: 0.75rem 0 0.25rem 0;">
        <strong>Interpretation:</strong>
      </p>
      <ul style="margin: 0; padding-left: 1.5rem;">
        <li>\(\hat{\rho}(0) = 1\): Perfect correlation with itself</li>
        <li>\(\hat{\rho}(\tau) \to 0\) as \(\tau \to \infty\): Samples become independent (for ergodic chains)</li>
        <li><strong>Slow decay:</strong> High autocorrelation indicates the chain mixes slowly</li>
        <li><strong>Fast decay:</strong> Low autocorrelation indicates efficient exploration</li>
      </ul>
    </div>
    
    <div class="canvas-label">Autocorrelation Function (ACF)</div>
    <canvas id="acfXY" width="100%" height="350" style="width: 100%;"></canvas>
    
    <p style="margin-top: 1rem; color: #4a5568; font-size: 0.9rem;">
      <strong>Blue line:</strong> ACF for \(x_1\) parameter. 
      <strong>Red line:</strong> ACF for \(x_2\) parameter.
      The lag range adapts automatically—showing where the ACF crosses zero plus 33% additional lags 
      to verify convergence to independence.
    </p>

    <h3 style="font-size: 1.1rem; font-weight: 600; margin: 2rem 0 1rem 0;">Performance Metrics</h3>
    <div class="stats-grid" style="margin-top: 1rem;">
      <div class="stat-item">
        <div class="stat-label">Total Iterations</div>
        <div class="stat-value" id="totalIter">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Acceptance Rate</div>
        <div class="stat-value" id="acceptRate">—</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Accepted Proposals</div>
        <div class="stat-value" id="acceptCount">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Effective Sample Size (est.)</div>
        <div class="stat-value" id="essValue">—</div>
      </div>
    </div>
    
    <div class="algorithm-box" style="margin-top: 1.5rem;">
      <strong>Effective Sample Size (ESS)</strong>
      <p style="margin: 0.75rem 0;">
        Due to autocorrelation, MCMC samples are not independent. The ESS estimates how many independent 
        samples our correlated chain is equivalent to:
      </p>
      $$\text{ESS} \approx \frac{n}{1 + 2\sum_{\tau=1}^{\infty} \rho(\tau)}$$
      <p style="margin: 0.75rem 0 0 0; font-size: 0.9rem;">
        where \(n\) is the total number of samples and \(\rho(\tau)\) is the ACF. Higher ESS means more 
        efficient sampling. The ratio ESS/\(n\) is called the <strong>sampling efficiency</strong>.
      </p>
    </div>
    
    <div class="info-note" style="margin-top: 1.5rem;">
      <strong>Tuning the Proposal Width:</strong> The proposal standard deviation \(\sigma\) directly affects 
      both the acceptance rate and the autocorrelation. For random-walk Metropolis in high dimensions, 
      the asymptotically optimal acceptance rate is approximately 0.234 (Roberts et al., 1997; Roberts & Rosenthal, 2001). 
      For low-dimensional problems (2D), acceptance rates between 40-60% are typically more efficient, 
      though the optimal rate depends on the target distribution's geometry.
    </div>
  </div>

  <!-- STRENGTHS AND LIMITATIONS -->
  <div class="section">
    <h2 class="section-title">Strengths & Limitations of HMC</h2>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-top: 1rem;">
      <div class="algorithm-box">
        <strong style="color: #059669;">✓ Strengths</strong>
        <ul style="margin: 0.75rem 0 0 0; padding-left: 1.5rem;">
          <li style="margin: 0.5rem 0;"><strong>Efficient exploration:</strong> Makes large, coherent moves instead of random walks</li>
          <li style="margin: 0.5rem 0;"><strong>Reduced autocorrelation:</strong> Much lower correlation between samples than MH</li>
          <li style="margin: 0.5rem 0;"><strong>Handles correlations naturally:</strong> Follows posterior geometry via gradients</li>
          <li style="margin: 0.5rem 0;"><strong>High acceptance rates:</strong> Typically 65-90% (vs. 23-40% for MH)</li>
          <li style="margin: 0.5rem 0;"><strong>Scales to high dimensions:</strong> Performance relatively better as \(d\) increases</li>
        </ul>
      </div>
      
      <div class="algorithm-box">
        <strong style="color: #dc2626;">✗ Limitations</strong>
        <ul style="margin: 0.75rem 0 0 0; padding-left: 1.5rem;">
          <li style="margin: 0.5rem 0;"><strong>Requires gradients:</strong> Need \(\nabla \log \pi(\mathbf{q})\), which isn't always available</li>
          <li style="margin: 0.5rem 0;"><strong>Tuning parameters:</strong> Step size \(\epsilon\) and trajectory length \(L\) need tuning</li>
          <li style="margin: 0.5rem 0;"><strong>Computational cost:</strong> Each iteration requires \(L\) gradient evaluations</li>
          <li style="margin: 0.5rem 0;"><strong>Numerical errors:</strong> Discretization of continuous dynamics introduces error</li>
          <li style="margin: 0.5rem 0;"><strong>Still struggles with multimodality:</strong> Difficult to jump between well-separated modes</li>
        </ul>
      </div>
    </div>
    
    <div class="info-note" style="margin-top: 1.5rem;">
      <strong>When to use HMC:</strong>
      <ul style="margin: 0.5rem 0 0 0; padding-left: 1.5rem;">
        <li><strong>Smooth posteriors:</strong> HMC excels when \(\pi(\mathbf{q})\) is differentiable and relatively smooth</li>
        <li><strong>High dimensions:</strong> Particularly valuable for \(d > 10\), where random-walk methods struggle</li>
        <li><strong>Strong correlations:</strong> Automatically adapts to correlation structure via gradient information</li>
        <li><strong>Modern variants:</strong> NUTS (No-U-Turn Sampler) in Stan/PyMC automatically tunes \(\epsilon\) and \(L\), 
        making HMC much more practical</li>
      </ul>
    </div>
  </div>

  <!-- COMPARISON WITH MH -->
  <div class="section">
    <h2 class="section-title">Comparison: HMC vs. Metropolis–Hastings</h2>
    <p>
      Direct comparison on the same target distributions reveals HMC's advantages:
    </p>
    
    <div class="algorithm-box" style="margin-top: 1rem;">
      <strong>Key Differences:</strong>
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-top: 1rem;">
        <div><strong>Property</strong></div>
        <div><strong>Metropolis–Hastings</strong></div>
        <div><strong>HMC</strong></div>
        
        <div style="padding: 0.5rem 0; border-top: 1px solid #e2e8f0;">Proposal mechanism</div>
        <div style="padding: 0.5rem 0; border-top: 1px solid #e2e8f0;">Random walk</div>
        <div style="padding: 0.5rem 0; border-top: 1px solid #e2e8f0;">Hamiltonian dynamics</div>
        
        <div style="padding: 0.5rem 0;">Gradients needed?</div>
        <div style="padding: 0.5rem 0;">No</div>
        <div style="padding: 0.5rem 0;">Yes</div>
        
        <div style="padding: 0.5rem 0;">Typical acceptance rate</div>
        <div style="padding: 0.5rem 0;">23-40% (high-d)</div>
        <div style="padding: 0.5rem 0;">65-90%</div>
        
        <div style="padding: 0.5rem 0;">Autocorrelation</div>
        <div style="padding: 0.5rem 0;">High</div>
        <div style="padding: 0.5rem 0;">Low</div>
        
        <div style="padding: 0.5rem 0;">Effective sample size</div>
        <div style="padding: 0.5rem 0;">Much lower than \(n\)</div>
        <div style="padding: 0.5rem 0;">Closer to \(n\)</div>
        
        <div style="padding: 0.5rem 0;">Best for</div>
        <div style="padding: 0.5rem 0;">Low-d, gradients unavailable</div>
        <div style="padding: 0.5rem 0;">High-d, smooth posteriors</div>
      </div>
    </div>
    
    <div style="margin-top: 1.5rem;">
      <p>
        <strong>Try it yourself:</strong> Run both samplers on the same distribution (especially the banana or funnel) 
        and compare the trace plots and ACF. HMC typically shows:
      </p>
      <ul style="padding-left: 1.5rem;">
        <li>Longer jumps in parameter space (less "sticky")</li>
        <li>Faster ACF decay to zero</li>
        <li>Higher effective sample size for the same number of iterations</li>
        <li>Better exploration of curved correlations (banana) and varying scales (funnel)</li>
      </ul>
    </div>
  </div>
          <strong>Key advantage:</strong> Explores parameter space coherently rather than randomly, 
          dramatically reducing autocorrelation.
        </p>
      </div>
      
      <div class="algorithm-box">
        <strong>Nested Sampling</strong>
        <p style="margin: 0.75rem 0; font-size: 0.9rem;">
          A fundamentally different approach that simultaneously computes samples from the posterior 
          <em>and</em> the model evidence (marginal likelihood). Instead of evolving a Markov chain, 
          nested sampling progressively samples from constrained priors with increasing likelihood thresholds.
        </p>
        <p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #4a5568;">
  </div>

  <!-- REFERENCES -->
  <div class="section">
    <h2 class="section-title">References & Further Reading</h2>
    <div style="font-size: 0.9rem; line-height: 1.8;">
      <p><strong>Key Papers:</strong></p>
      <ul style="padding-left: 1.5rem; margin: 0.5rem 0;">
        <li>Duane, S., Kennedy, A.D., Pendleton, B.J., & Roweth, D. (1987). 
        "Hybrid Monte Carlo." <em>Physics Letters B</em>, 195(2), 216-222.</li>
        <li>Neal, R.M. (1996). "Bayesian Learning for Neural Networks." PhD Thesis, University of Toronto.</li>
        <li>Neal, R.M. (2011). "MCMC Using Hamiltonian Dynamics." <em>Handbook of Markov Chain Monte Carlo</em> 
        (eds. Brooks et al.), CRC Press, 113-162.</li>
        <li>Betancourt, M. (2017). "A Conceptual Introduction to Hamiltonian Monte Carlo." 
        <em>arXiv:1701.02434</em>.</li>
        <li>Hoffman, M.D., & Gelman, A. (2014). "The No-U-Turn Sampler: Adaptively Setting Path Lengths in Hamiltonian Monte Carlo." 
        <em>Journal of Machine Learning Research</em>, 15(1), 1593-1623.</li>
        <li>Haario, H., Saksman, E., & Tamminen, J. (1999). "Adaptive Proposal Distribution for Random Walk Metropolis Algorithm." 
        <em>Computational Statistics</em>, 14, 375-395.</li>
      </ul>
      
      <p style="margin-top: 1rem;"><strong>Books:</strong></p>
      <ul style="padding-left: 1.5rem; margin: 0.5rem 0;">
        <li>Brooks, S., Gelman, A., Jones, G., & Meng, X.-L. (2011). <em>Handbook of Markov Chain Monte Carlo</em>. CRC Press.</li>
        <li>Gelman, A., Carlin, J.B., Stern, H.S., Dunson, D.B., Vehtari, A., & Rubin, D.B. (2013). 
        <em>Bayesian Data Analysis</em> (3rd ed.). CRC Press.</li>
        <li>Betancourt, M. (2018). <em>A Conceptual Introduction to Hamiltonian Monte Carlo</em>. 
        arXiv preprint. (Excellent pedagogical resource)</li>
      </ul>
      
      <p style="margin-top: 1rem;"><strong>Software Implementations:</strong></p>
      <ul style="padding-left: 1.5rem; margin: 0.5rem 0;">
        <li><strong>Stan:</strong> <a href="https://mc-stan.org/" style="color: #667eea;">mc-stan.org</a> 
        - Uses NUTS (No-U-Turn Sampler), an adaptive HMC variant</li>
        <li><strong>PyMC:</strong> <a href="https://www.pymc.io/" style="color: #667eea;">pymc.io</a> 
        - Python probabilistic programming with HMC/NUTS</li>
        <li><strong>NumPyro:</strong> JAX-based probabilistic programming with efficient HMC</li>
      </ul>
    </div>
  </div>

</div>

<script>
/***************************************************
 * CANVAS & UI SETUP
 ***************************************************/
const canvas = document.getElementById("posterior");
const ctx = canvas.getContext("2d");
const hxCanvas = document.getElementById("histX");
const hyCanvas = document.getElementById("histY");
const hx = hxCanvas.getContext("2d");
const hy = hyCanvas.getContext("2d");
const acfCanvas = document.getElementById("acfXY");
const acfXY = acfCanvas.getContext("2d");
const traceXCanvas = document.getElementById("traceX");
const traceYCanvas = document.getElementById("traceY");
const traceX = traceXCanvas.getContext("2d");
const traceY = traceYCanvas.getContext("2d");

// Set canvas widths to actual container width
acfCanvas.width = acfCanvas.offsetWidth;
traceXCanvas.width = traceXCanvas.offsetWidth;
traceYCanvas.width = traceYCanvas.offsetWidth;

const stepInfo = document.getElementById("stepInfo");
const epsilonSlider = document.getElementById("epsilon");
const numStepsSlider = document.getElementById("numSteps");
const speedSlider = document.getElementById("speed");
const epsilonVal = document.getElementById("epsilonVal");
const numStepsVal = document.getElementById("numStepsVal");
const speedVal = document.getElementById("speedVal");

epsilonSlider.oninput = () => {
  epsilonVal.textContent = parseFloat(epsilonSlider.value).toFixed(2);
};

numStepsSlider.oninput = () => {
  numStepsVal.textContent = numStepsSlider.value;
};

speedSlider.oninput = () => {
  speedVal.textContent = speedSlider.value;
  if (timer) {
    clearInterval(timer);
    timer = setInterval(hmcStep, parseInt(speedSlider.value));
  }
};

/***************************************************
 * DOMAIN & STATE
 ***************************************************/
// Domain will be set based on distribution
let xmin, xmax, ymin, ymax;

function setDomain() {
  const type = document.getElementById("dist").value;
  if (type === "funnel") {
    // Neal's funnel: x ~ N(0, 3^2), y|x ~ N(0, exp(x)^2)
    // x covers ±3 std devs = ±9, use ±10 to be safe
    // For y: when x is large, exp(x) is huge. At x=5, exp(5)≈150
    // So y needs range of about ±3*150 = ±450, but let's use ±50 for visualization
    xmin = -10; xmax = 10;
    ymin = -50; ymax = 50;
  } else if (type === "banana") {
    // Rosenbrock banana: x² + 100(y - x²)² ≤ C
    // For 95% probability mass, C ≈ 200 * 5.99 ≈ 1200
    // So x² ≤ 1200 → x ∈ [-35, 35], but main mass is closer
    // The banana curves upward: when x=±2, y ≈ x² = 4
    // Most mass is in x ∈ [-2.5, 2.5], y ∈ [-1, 7]
    xmin = -3; xmax = 3;
    ymin = -1; ymax = 8;
  } else {
    // Gaussian: bivariate with ρ=0.8, unit variance
    // ±4 standard deviations covers 99.99%
    xmin = -4; xmax = 4;
    ymin = -4; ymax = 4;
  }
}

// Initialize domain
setDomain();

const samplesX = [];
const samplesY = [];

let x = 0, y = 0;
let p = 0;
let accepted = 0, total = 0;
let timer = null;

/***************************************************
 * TARGET DISTRIBUTIONS
 ***************************************************/
function target(x, y) {
  const type = document.getElementById("dist").value;
  if (type === "funnel") return targetFunnel(x, y);
  if (type === "banana") return targetBanana(x, y);
  return targetGaussian(x, y);
}

function targetGaussian(x, y) {
  // Bivariate Gaussian with correlation rho = 0.8
  const rho = 0.8;
  const exponent = (x*x - 2*rho*x*y + y*y) / (2 * (1 - rho*rho));
  return Math.exp(-exponent);
}

function targetBanana(x, y) {
  // Rosenbrock's banana distribution
  // π(x,y) ∝ exp(-1/200 * (x² + 100(y - x²)²))
  const exponent = (x*x + 100 * (y - x*x)**2) / 200;
  return Math.exp(-exponent);
}

function targetFunnel(x, y) {
  // Neal's funnel distribution
  // x ~ N(0, 3²), y|x ~ N(0, exp(x)²)
  // π(x,y) ∝ exp(-x²/18 - y²/(2*exp(2x)))
  const ex = Math.exp(x);
  const exponent = x*x / 18 + y*y / (2 * ex * ex);
  return Math.exp(-exponent);
}

/***************************************************
 * GRADIENTS OF NEGATIVE LOG POSTERIOR (for HMC)
 ***************************************************/
// Gradient of U(q) = -log π(q)
function gradU(x, y) {
  const type = document.getElementById("dist").value;
  if (type === "funnel") return gradUFunnel(x, y);
  if (type === "banana") return gradUBanana(x, y);
  return gradUGaussian(x, y);
}

function gradUGaussian(x, y) {
  // U = (x² - 2ρxy + y²)/(2(1-ρ²))
  // ∂U/∂x = (2x - 2ρy)/(2(1-ρ²)) = (x - ρy)/(1-ρ²)
  // ∂U/∂y = (2y - 2ρx)/(2(1-ρ²)) = (y - ρx)/(1-ρ²)
  const rho = 0.8;
  const denom = 1 - rho*rho;
  return [(x - rho*y) / denom, (y - rho*x) / denom];
}

function gradUBanana(x, y) {
  // U = (x² + 100(y - x²)²)/200
  // ∂U/∂x = (2x + 100·2(y - x²)·(-2x))/200 = (x - 200x(y - x²))/100
  // ∂U/∂y = 100·2(y - x²)/200 = (y - x²)
  const diff = y - x*x;
  return [(x - 200*x*diff) / 100, diff];
}

function gradUFunnel(x, y) {
  // U = x²/18 + y²/(2exp(2x))
  // ∂U/∂x = 2x/18 - y²·exp(-2x)
  // ∂U/∂y = y·exp(-2x)
  const ex = Math.exp(x);
  return [x / 9 - y*y / (ex*ex), y / (ex*ex)];
}

/***************************************************
 * COORDINATE TRANSFORMATION
 ***************************************************/
function toCanvas(x, y) {
  const px = (x - xmin) / (xmax - xmin) * canvas.width;
  const py = canvas.height - (y - ymin) / (ymax - ymin) * canvas.height;
  return [px, py];
}

/***************************************************
 * DRAW DENSITY WITH PROPER AXES
 ***************************************************/
function drawDensity() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Compute density grid
  const n = 200;
  const density = [];
  let maxP = 0;
  
  for (let i = 0; i < n; i++) {
    density[i] = [];
    for (let j = 0; j < n; j++) {
      const xVal = xmin + (xmax - xmin) * i / n;
      const yVal = ymin + (ymax - ymin) * j / n;
      const pVal = target(xVal, yVal);
      density[i][j] = pVal;
      if (pVal > maxP) maxP = pVal;
    }
  }

  // Draw density heatmap
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const alpha = Math.min(0.9, Math.max(0.05, 8 * density[i][j] / maxP));
      ctx.fillStyle = `rgba(17, 24, 39, ${alpha})`;
      ctx.fillRect(
        i * canvas.width / n,
        canvas.height - j * canvas.height / n,
        canvas.width / n + 1,
        canvas.height / n + 1
      );
    }
  }

  // Grid lines
  ctx.strokeStyle = "#e0e0e0";
  ctx.lineWidth = 0.5;
  const gridN = 8;
  for (let i = 0; i <= gridN; i++) {
    const pos = i / gridN * canvas.width;
    ctx.beginPath();
    ctx.moveTo(pos, 0);
    ctx.lineTo(pos, canvas.height);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, pos);
    ctx.lineTo(canvas.width, pos);
    ctx.stroke();
  }

  // Axes
  ctx.strokeStyle = "#2d3748";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, canvas.height);
  ctx.lineTo(canvas.width, canvas.height);
  ctx.moveTo(0, 0);
  ctx.lineTo(0, canvas.height);
  ctx.stroke();

  // Ticks and labels
  ctx.fillStyle = "#2d3748";
  ctx.font = "13px -apple-system, sans-serif";
  ctx.textAlign = "center";
  
  const nTicks = 8;
  for (let i = 0; i <= nTicks; i++) {
    const xPos = i / nTicks * canvas.width;
    const yPos = canvas.height - i / nTicks * canvas.height;
    const xLabel = (xmin + (xmax - xmin) * i / nTicks).toFixed(1);
    const yLabel = (ymin + (ymax - ymin) * i / nTicks).toFixed(1);
    
    // X-axis ticks
    ctx.beginPath();
    ctx.moveTo(xPos, canvas.height);
    ctx.lineTo(xPos, canvas.height - 8);
    ctx.stroke();
    ctx.fillText(xLabel, xPos, canvas.height + 20);
    
    // Y-axis ticks
    ctx.textAlign = "right";
    ctx.beginPath();
    ctx.moveTo(0, yPos);
    ctx.lineTo(8, yPos);
    ctx.stroke();
    ctx.fillText(yLabel, -12, yPos + 4);
    ctx.textAlign = "center";
  }

  // Axis labels
  ctx.font = "bold 16px -apple-system, sans-serif";
  ctx.fillStyle = "#1a1a1a";
  ctx.fillText("x₁", canvas.width / 2, canvas.height + 45);
  
  ctx.save();
  ctx.translate(15, canvas.height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText("x₂", 0, 0);
  ctx.restore();
}

/***************************************************
 * MH STEP
 ***************************************************/
/***************************************************
 * HMC STEP
 ***************************************************/
function hmcStep() {
  const epsilon = parseFloat(epsilonSlider.value);
  const L = parseInt(numStepsSlider.value);

  // Current position and energy
  const q0 = [x, y];
  const U0 = -Math.log(target(x, y));

  // Sample momentum
  const p0 = [randn(), randn()];
  const K0 = 0.5 * (p0[0]**2 + p0[1]**2);
  const H0 = U0 + K0;

  // Leapfrog integration
  let q = [q0[0], q0[1]];
  let p = [p0[0], p0[1]];

  // Half step for momentum
  let grad = gradU(q[0], q[1]);
  p[0] -= epsilon * 0.5 * grad[0];
  p[1] -= epsilon * 0.5 * grad[1];

  // Full steps
  for (let i = 0; i < L; i++) {
    // Full step for position
    q[0] += epsilon * p[0];
    q[1] += epsilon * p[1];

    // Full step for momentum (except last step)
    grad = gradU(q[0], q[1]);
    if (i < L - 1) {
      p[0] -= epsilon * grad[0];
      p[1] -= epsilon * grad[1];
    } else {
      // Half step for last
      p[0] -= epsilon * 0.5 * grad[0];
      p[1] -= epsilon * 0.5 * grad[1];
    }
  }

  // Proposed state and energy
  const targetVal = target(q[0], q[1]);
  const U1 = targetVal > 0 ? -Math.log(targetVal) : 1e10;
  const K1 = 0.5 * (p[0]**2 + p[1]**2);
  const H1 = U1 + K1;

  // Metropolis acceptance
  const deltaH = H1 - H0;
  const acceptProb = Math.min(1, Math.exp(-deltaH));
  const u = Math.random();

  let acc = false;
  if (u < acceptProb) {
    x = q[0];
    y = q[1];
    acc = true;
    accepted++;
  }

  total++;
  samplesX.push(x);
  samplesY.push(y);

  // Draw point on canvas
  const [px, py] = toCanvas(x, y);
  ctx.fillStyle = acc ? "#38a169" : "#ed8936";
  ctx.beginPath();
  ctx.arc(px, py, 3.5, 0, 2 * Math.PI);
  ctx.fill();
  ctx.strokeStyle = "white";
  ctx.lineWidth = 0.5;
  ctx.stroke();

  // Draw trajectory (show the leapfrog path)
  if (L > 5) {
    ctx.strokeStyle = acc ? "rgba(56, 161, 105, 0.3)" : "rgba(237, 137, 54, 0.3)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    
    // Recompute trajectory for visualization
    let qt = [q0[0], q0[1]];
    let pt = [p0[0], p0[1]];
    const [px0, py0] = toCanvas(qt[0], qt[1]);
    ctx.moveTo(px0, py0);
    
    let gradt = gradU(qt[0], qt[1]);
    pt[0] -= epsilon * 0.5 * gradt[0];
    pt[1] -= epsilon * 0.5 * gradt[1];
    
    for (let i = 0; i < L; i++) {
      qt[0] += epsilon * pt[0];
      qt[1] += epsilon * pt[1];
      const [pxt, pyt] = toCanvas(qt[0], qt[1]);
      ctx.lineTo(pxt, pyt);
      
      gradt = gradU(qt[0], qt[1]);
      if (i < L - 1) {
        pt[0] -= epsilon * gradt[0];
        pt[1] -= epsilon * gradt[1];
      } else {
        pt[0] -= epsilon * 0.5 * gradt[0];
        pt[1] -= epsilon * 0.5 * gradt[1];
      }
    }
    ctx.stroke();
  }

  // Update displays
  drawHistograms();
  updateStepInfo(q[0], q[1], H0, H1, deltaH, acceptProb, u, acc);
  updateStats();
}

/***************************************************
 * UPDATE STEP INFO
 ***************************************************/
function updateStepInfo(qx, qy, H0, H1, deltaH, acceptProb, u, acc) {
  const statusClass = acc ? 'status-accepted' : 'status-rejected';
  const statusText = acc ? 'ACCEPTED ✓' : 'REJECTED ✗';
  
  stepInfo.innerHTML = `
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
      <div>
        <strong>Current State (t)</strong><br>
        q₁ = ${x.toFixed(4)}<br>
        q₂ = ${y.toFixed(4)}<br>
        H(q<sub>t</sub>, p) = ${H0.toFixed(4)}
      </div>
      <div>
        <strong>Proposed State (after trajectory)</strong><br>
        q₁′ = ${qx.toFixed(4)}<br>
        q₂′ = ${qy.toFixed(4)}<br>
        H(q′, p′) = ${H1.toFixed(4)}
      </div>
    </div>
    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e2e8f0;">
      <strong>Hamiltonian Dynamics</strong><br>
      Initial Hamiltonian: H₀ = ${H0.toFixed(4)}<br>
      Final Hamiltonian: H₁ = ${H1.toFixed(4)}<br>
      Change in energy: ΔH = ${deltaH.toFixed(4)}<br>
      <div style="margin-top: 0.5rem;">
        <strong>Metropolis Acceptance</strong><br>
        Accept prob: α = exp(-ΔH) = ${acceptProb.toFixed(4)}<br>
        Random draw: u = ${u.toFixed(4)}<br>
        <span style="font-size: 1.1rem; margin-top: 0.5rem; display: inline-block;" class="${statusClass}">
          ${statusText}
        </span>
      </div>
    </div>
  `;
}

/***************************************************
 * UPDATE STATISTICS
 ***************************************************/
function updateStats() {
  document.getElementById("totalIter").textContent = total.toLocaleString();
  document.getElementById("acceptCount").textContent = accepted.toLocaleString();
  
  const rate = accepted / total;
  document.getElementById("acceptRate").textContent = 
    (rate * 100).toFixed(1) + "% (" + accepted + "/" + total + ")";
  
  // Estimate ESS from ACF
  if (samplesX.length > 50) {
    const acfX = autocorr(samplesX, 100);
    let sumACF = 0;
    for (let i = 1; i < acfX.length && acfX[i] > 0; i++) {
      sumACF += acfX[i];
    }
    const ess = samplesX.length / (1 + 2 * sumACF);
    document.getElementById("essValue").textContent = Math.round(ess).toLocaleString();
  }
}

/***************************************************
 * HISTOGRAMS
 ***************************************************/
function drawHistograms() {
  drawHistogram(hx, samplesX, "x₁", hxCanvas);
  drawHistogram(hy, samplesY, "x₂", hyCanvas);
  drawACFXY(acfXY, samplesX, samplesY);
  drawTracePlot(traceX, samplesX, "x₁", traceXCanvas);
  drawTracePlot(traceY, samplesY, "x₂", traceYCanvas);
}

function drawHistogram(ctx, data, label, canvas) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  if (data.length === 0) return;

  const bins = 40;
  const hist = Array(bins).fill(0);
  const binWidth = (xmax - xmin) / bins;

  data.forEach(v => {
    const i = Math.floor((v - xmin) / (xmax - xmin) * bins);
    if (i >= 0 && i < bins) hist[i]++;
  });

  const hmax = Math.max(...hist, 1);
  
  // Normalize histogram to approximate density
  const normalized = hist.map(h => h / (data.length * binWidth));
  const ymax = Math.max(...normalized, 0.01);

  const margin = {top: 20, right: 20, bottom: 50, left: 55};
  const plotWidth = canvas.width - margin.left - margin.right;
  const plotHeight = canvas.height - margin.top - margin.bottom;

  // Draw bars
  hist.forEach((h, i) => {
    const x = margin.left + i * plotWidth / bins;
    const barHeight = (h / hmax) * plotHeight;
    ctx.fillStyle = "#374151";
    ctx.fillRect(x, margin.top + plotHeight - barHeight, plotWidth / bins - 1, barHeight);
  });

  // Axes
  ctx.strokeStyle = "#2d3748";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + plotHeight);
  ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
  ctx.stroke();

  // X-axis ticks
  ctx.fillStyle = "#2d3748";
  ctx.font = "12px -apple-system, sans-serif";
  ctx.textAlign = "center";
  const xTicks = 8;
  for (let i = 0; i <= xTicks; i++) {
    const xPos = margin.left + i / xTicks * plotWidth;
    const xLabel = (xmin + (xmax - xmin) * i / xTicks).toFixed(1);
    ctx.beginPath();
    ctx.moveTo(xPos, margin.top + plotHeight);
    ctx.lineTo(xPos, margin.top + plotHeight + 5);
    ctx.stroke();
    ctx.fillText(xLabel, xPos, margin.top + plotHeight + 20);
  }

  // Y-axis ticks
  ctx.textAlign = "right";
  const yTicks = 5;
  for (let i = 0; i <= yTicks; i++) {
    const yPos = margin.top + plotHeight - i / yTicks * plotHeight;
    const yLabel = (ymax * i / yTicks).toFixed(2);
    ctx.beginPath();
    ctx.moveTo(margin.left - 5, yPos);
    ctx.lineTo(margin.left, yPos);
    ctx.stroke();
    ctx.fillText(yLabel, margin.left - 10, yPos + 4);
  }

  // Labels
  ctx.font = "bold 14px -apple-system, sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(label, margin.left + plotWidth / 2, canvas.height - 10);
  
  ctx.save();
  ctx.translate(15, margin.top + plotHeight / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText("Density", 0, 0);
  ctx.restore();
}

/***************************************************
 * TRACE PLOTS
 ***************************************************/
function drawTracePlot(ctx, data, label, canvas) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  if (data.length < 2) return;

  const margin = {top: 20, right: 50, bottom: 50, left: 70};
  const plotWidth = canvas.width - margin.left - margin.right;
  const plotHeight = canvas.height - margin.top - margin.bottom;

  // Find data range
  const yMin = Math.min(...data, -4);
  const yMax = Math.max(...data, 4);
  const yRange = yMax - yMin;
  const yPadding = yRange * 0.1;

  // Grid
  ctx.strokeStyle = "#e5e7eb";
  ctx.lineWidth = 1;
  const xTicks = 10;
  const yTicks = 6;
  
  for (let i = 0; i <= xTicks; i++) {
    const x = margin.left + i / xTicks * plotWidth;
    ctx.beginPath();
    ctx.moveTo(x, margin.top);
    ctx.lineTo(x, margin.top + plotHeight);
    ctx.stroke();
  }
  
  for (let i = 0; i <= yTicks; i++) {
    const y = margin.top + i / yTicks * plotHeight;
    ctx.beginPath();
    ctx.moveTo(margin.left, y);
    ctx.lineTo(margin.left + plotWidth, y);
    ctx.stroke();
  }

  // Draw trace line - use different color based on label
  ctx.strokeStyle = label === "x₁" ? "#1e40af" : "#dc2626";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  
  for (let i = 0; i < data.length; i++) {
    const xPos = margin.left + i / (data.length - 1) * plotWidth;
    const yPos = margin.top + plotHeight - (data[i] - (yMin - yPadding)) / (yMax - yMin + 2 * yPadding) * plotHeight;
    
    if (i === 0) ctx.moveTo(xPos, yPos);
    else ctx.lineTo(xPos, yPos);
  }
  ctx.stroke();

  // Axes
  ctx.strokeStyle = "#2d3748";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + plotHeight);
  ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
  ctx.stroke();

  // X-axis ticks and labels
  ctx.fillStyle = "#2d3748";
  ctx.font = "12px -apple-system, sans-serif";
  ctx.textAlign = "center";
  
  for (let i = 0; i <= xTicks; i++) {
    const x = margin.left + i / xTicks * plotWidth;
    const iterLabel = Math.round(i / xTicks * (data.length - 1));
    ctx.beginPath();
    ctx.moveTo(x, margin.top + plotHeight);
    ctx.lineTo(x, margin.top + plotHeight + 6);
    ctx.stroke();
    ctx.fillText(iterLabel, x, margin.top + plotHeight + 20);
  }
  
  ctx.font = "bold 13px -apple-system, sans-serif";
  ctx.fillText("Iteration", margin.left + plotWidth / 2, canvas.height - 10);

  // Y-axis ticks and labels
  ctx.textAlign = "right";
  ctx.font = "12px -apple-system, sans-serif";
  
  for (let i = 0; i <= yTicks; i++) {
    const y = margin.top + plotHeight - i / yTicks * plotHeight;
    const val = (yMin - yPadding) + i / yTicks * (yMax - yMin + 2 * yPadding);
    ctx.beginPath();
    ctx.moveTo(margin.left - 6, y);
    ctx.lineTo(margin.left, y);
    ctx.stroke();
    ctx.fillText(val.toFixed(2), margin.left - 10, y + 4);
  }
  
  ctx.font = "bold 13px -apple-system, sans-serif";
  ctx.save();
  ctx.translate(20, margin.top + plotHeight / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = "center";
  ctx.fillText(label + " value", 0, 0);
  ctx.restore();
}

/***************************************************
 * AUTOCORRELATION
 ***************************************************/
function autocorr(data, lagMax = 100) {
  const n = data.length;
  if (n === 0) return [];
  
  const mean = data.reduce((a, b) => a + b, 0) / n;
  const totalVar = data.reduce((a, b) => a + (b - mean)**2, 0);
  
  if (totalVar === 0) return Array(lagMax + 1).fill(0);
  
  const acf = [];
  for (let lag = 0; lag <= lagMax; lag++) {
    let c = 0;
    for (let i = 0; i < n - lag; i++) {
      c += (data[i] - mean) * (data[i + lag] - mean);
    }
    acf.push(c / totalVar);
  }
  return acf;
}

function drawACFXY(ctx, dataX, dataY) {
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  
  if (dataX.length < 10) return;

  // Start with a reasonable max lag
  const initialLagMax = Math.min(300, Math.floor(dataX.length / 2));
  const acfX = autocorr(dataX, initialLagMax);
  const acfY = autocorr(dataY, initialLagMax);
  
  // Find where ACF crosses zero for both chains
  function findZeroCrossing(acf) {
    for (let i = 1; i < acf.length; i++) {
      if (acf[i] <= 0) return i;
    }
    return acf.length - 1;
  }
  
  const zeroCrossX = findZeroCrossing(acfX);
  const zeroCrossY = findZeroCrossing(acfY);
  const maxZeroCross = Math.max(zeroCrossX, zeroCrossY);
  
  // Show zero crossing + 1/3 more, but at least 50 lags and at most initialLagMax
  const adaptiveLagMax = Math.min(initialLagMax, Math.max(50, Math.floor(maxZeroCross * 1.33)));
  
  // Trim ACF arrays to adaptive length
  const acfXTrimmed = acfX.slice(0, adaptiveLagMax + 1);
  const acfYTrimmed = acfY.slice(0, adaptiveLagMax + 1);
  const n = acfXTrimmed.length;

  const margin = {top: 30, right: 100, bottom: 60, left: 70};
  const plotWidth = ctx.canvas.width - margin.left - margin.right;
  const plotHeight = ctx.canvas.height - margin.top - margin.bottom;

  const yMin = -0.2;
  const yMax = 1.0;

  // Grid
  ctx.strokeStyle = "#e5e7eb";
  ctx.lineWidth = 1;
  const xTicks = 10;
  const yTicks = 6;
  
  for (let i = 0; i <= xTicks; i++) {
    const x = margin.left + i / xTicks * plotWidth;
    ctx.beginPath();
    ctx.moveTo(x, margin.top);
    ctx.lineTo(x, margin.top + plotHeight);
    ctx.stroke();
  }
  
  for (let i = 0; i <= yTicks; i++) {
    const y = margin.top + i / yTicks * plotHeight;
    ctx.beginPath();
    ctx.moveTo(margin.left, y);
    ctx.lineTo(margin.left + plotWidth, y);
    ctx.stroke();
  }

  // Zero line
  const zeroY = margin.top + (yMax - 0) / (yMax - yMin) * plotHeight;
  ctx.strokeStyle = "#94a3b8";
  ctx.lineWidth = 1.5;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(margin.left, zeroY);
  ctx.lineTo(margin.left + plotWidth, zeroY);
  ctx.stroke();
  ctx.setLineDash([]);

  // Draw ACF for x₁
  ctx.strokeStyle = "#1e40af";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for (let i = 0; i < n; i++) {
    const xPos = margin.left + i / (n - 1) * plotWidth;
    const yPos = margin.top + (yMax - acfXTrimmed[i]) / (yMax - yMin) * plotHeight;
    if (i === 0) ctx.moveTo(xPos, yPos);
    else ctx.lineTo(xPos, yPos);
  }
  ctx.stroke();

  // Draw ACF for x₂
  ctx.strokeStyle = "#dc2626";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for (let i = 0; i < n; i++) {
    const xPos = margin.left + i / (n - 1) * plotWidth;
    const yPos = margin.top + (yMax - acfYTrimmed[i]) / (yMax - yMin) * plotHeight;
    if (i === 0) ctx.moveTo(xPos, yPos);
    else ctx.lineTo(xPos, yPos);
  }
  ctx.stroke();

  // Axes
  ctx.strokeStyle = "#2d3748";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + plotHeight);
  ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
  ctx.stroke();

  // X-axis ticks and labels
  ctx.fillStyle = "#2d3748";
  ctx.font = "13px -apple-system, sans-serif";
  ctx.textAlign = "center";
  
  for (let i = 0; i <= xTicks; i++) {
    const x = margin.left + i / xTicks * plotWidth;
    const lag = Math.round(i / xTicks * adaptiveLagMax);
    ctx.beginPath();
    ctx.moveTo(x, margin.top + plotHeight);
    ctx.lineTo(x, margin.top + plotHeight + 6);
    ctx.stroke();
    ctx.fillText(lag, x, margin.top + plotHeight + 22);
  }
  
  ctx.font = "bold 14px -apple-system, sans-serif";
  ctx.fillText("Lag τ", margin.left + plotWidth / 2, ctx.canvas.height - 15);

  // Y-axis ticks and labels
  ctx.textAlign = "right";
  ctx.font = "13px -apple-system, sans-serif";
  const yLabels = [-0.2, 0, 0.2, 0.4, 0.6, 0.8, 1.0];
  
  yLabels.forEach(val => {
    const y = margin.top + (yMax - val) / (yMax - yMin) * plotHeight;
    ctx.beginPath();
    ctx.moveTo(margin.left - 6, y);
    ctx.lineTo(margin.left, y);
    ctx.stroke();
    ctx.fillText(val.toFixed(1), margin.left - 12, y + 4);
  });
  
  ctx.font = "bold 14px -apple-system, sans-serif";
  ctx.save();
  ctx.translate(20, margin.top + plotHeight / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = "center";
  ctx.fillText("ACF", 0, 0);
  ctx.restore();

  // Legend
  ctx.textAlign = "left";
  ctx.font = "13px -apple-system, sans-serif";
  
  ctx.fillStyle = "#1e40af";
  ctx.fillRect(ctx.canvas.width - 85, 20, 15, 3);
  ctx.fillStyle = "#2d3748";
  ctx.fillText("x₁ chain", ctx.canvas.width - 65, 25);
  
  ctx.fillStyle = "#dc2626";
  ctx.fillRect(ctx.canvas.width - 85, 40, 15, 3);
  ctx.fillStyle = "#2d3748";
  ctx.fillText("x₂ chain", ctx.canvas.width - 65, 45);
}

/***************************************************
 * CONTROLS
 ***************************************************/
function start() {
  if (timer) {
    clearInterval(timer);
    timer = null;
    return;
  }
  timer = setInterval(hmcStep, parseInt(speedSlider.value));
}

function singleStep() {
  hmcStep();
}

function reset() {
  if (timer) {
    clearInterval(timer);
    timer = null;
  }
  
  // Update domain based on selected distribution
  setDomain();
  
  samplesX.length = 0;
  samplesY.length = 0;
  
  // Set initial position based on distribution
  const type = document.getElementById("dist").value;
  if (type === "funnel") {
    // Start near the neck of the funnel
    x = 0;
    y = 0;
  } else if (type === "banana") {
    // Start near the banana center
    x = 0;
    y = 0;
  } else {
    // Gaussian - start at origin
    x = 0;
    y = 0;
  }
  
  p = target(x, y);
  accepted = 0;
  total = 0;
  
  drawDensity();
  hx.clearRect(0, 0, hxCanvas.width, hxCanvas.height);
  hy.clearRect(0, 0, hyCanvas.width, hyCanvas.height);
  acfXY.clearRect(0, 0, acfCanvas.width, acfCanvas.height);
  traceX.clearRect(0, 0, traceXCanvas.width, traceXCanvas.height);
  traceY.clearRect(0, 0, traceYCanvas.width, traceYCanvas.height);
  
  stepInfo.innerHTML = "Click 'Start Sampling' or 'Single Step' to begin the MCMC algorithm.";
  
  document.getElementById("totalIter").textContent = "0";
  document.getElementById("acceptCount").textContent = "0";
  document.getElementById("acceptRate").textContent = "—";
  document.getElementById("essValue").textContent = "—";
}

/***************************************************
 * GAUSSIAN RNG (Box-Muller)
 ***************************************************/
function randn() {
  let u = 0, v = 0;
  while (u === 0) u = Math.random();
  while (v === 0) v = Math.random();
  return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

/***************************************************
 * INITIALIZATION
 ***************************************************/
p = target(x, y);
drawDensity();

// Add event listener to distribution selector to auto-reset on change
document.getElementById("dist").addEventListener("change", function() {
  reset();
});
</script>

</body>
</html>