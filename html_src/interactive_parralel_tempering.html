<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Parallel Tempering Demo | Jules Perret</title>
  <meta name="description" content="Interactive visualization of the Parallel Tempering (Temperature Ladder MCMC) algorithm for multimodal distributions" />

  <!-- MathJax for LaTeX rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      }
    };
  </script>

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #fafafa;
      color: #1a1a1a;
      margin: 0;
      padding: 0;
      line-height: 1.6;
    }

    /* Jekyll-compatible header navigation */
    .site-header {
      border-top: 5px solid #424242;
      border-bottom: 1px solid #e8e8e8;
      min-height: 55.95px;
      position: relative;
      background-color: white;
    }

    .site-header .wrapper {
      max-width: calc(1200px - (30px * 2));
      margin-right: auto;
      margin-left: auto;
      padding-right: 30px;
      padding-left: 30px;
    }

    .site-title {
      font-size: 26px;
      font-weight: 300;
      line-height: 54px;
      letter-spacing: -1px;
      margin-bottom: 0;
      float: left;
      text-decoration: none;
      color: #424242;
    }

    .site-title:hover {
      text-decoration: none;
      color: #111;
    }

    .site-nav {
      float: right;
      line-height: 54px;
    }

    .site-nav .nav-trigger {
      display: none;
    }

    .site-nav .menu-icon {
      display: none;
    }

    .site-nav .page-link {
      color: #111;
      line-height: 1.5;
      text-decoration: none;
      margin-left: 20px;
    }

    .site-nav .page-link:hover {
      text-decoration: underline;
    }

    .site-nav .page-link.active {
      font-weight: 600;
    }

    @media screen and (max-width: 600px) {
      .site-nav {
        position: absolute;
        top: 9px;
        right: 15px;
        background-color: #fdfdfd;
        border: 1px solid #e8e8e8;
        border-radius: 5px;
        text-align: right;
      }

      .site-nav label[for="nav-trigger"] {
        display: block;
        float: right;
        width: 36px;
        height: 36px;
        z-index: 2;
        cursor: pointer;
      }

      .site-nav .menu-icon {
        display: block;
        float: right;
        width: 36px;
        height: 26px;
        line-height: 0;
        padding-top: 10px;
        text-align: center;
      }

      .site-nav input ~ .trigger {
        clear: both;
        display: none;
      }

      .site-nav input:checked ~ .trigger {
        display: block;
        padding-bottom: 5px;
      }

      .site-nav .page-link {
        display: block;
        padding: 5px 10px;
        margin-left: 20px;
      }
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 300;
      margin-bottom: 0.5rem;
      color: #2d3748;
    }

    .subtitle {
      font-size: 1.1rem;
      color: #4a5568;
      margin-bottom: 2rem;
    }

    .section {
      background: white;
      border-radius: 8px;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 1rem;
      border-bottom: 2px solid #111827;
      padding-bottom: 0.5rem;
    }

    .algorithm-box {
      background: #f7fafc;
      border-left: 4px solid #667eea;
      padding: 1rem 1.5rem;
      margin: 1rem 0;
      border-radius: 4px;
    }

    .info-note {
      background: #ebf8ff;
      border-left: 4px solid #4299e1;
      padding: 1rem 1.5rem;
      margin: 1rem 0;
      border-radius: 4px;
    }

    .control-group {
      margin-bottom: 1.5rem;
    }

    .control-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: #2d3748;
    }

    .control-value {
      float: right;
      font-weight: 600;
      color: #111827;
      font-size: 1rem;
    }

    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #e2e8f0;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #111827;
      cursor: pointer;
      transition: all 0.2s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #374151;
      transform: scale(1.1);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #111827;
      cursor: pointer;
      border: none;
    }

    select {
      width: 100%;
      padding: 0.5rem;
      border: 2px solid #e2e8f0;
      border-radius: 4px;
      font-size: 1rem;
      background: white;
    }

    .button-group {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      flex-wrap: wrap;
    }

    button {
      flex: 1;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      background: #111827;
      color: white;
    }

    button.secondary {
      background: #4b5563;
      color: white;
    }

    button.secondary:hover {
      background: #6b7280;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      background: #374151;
    }

    button:active {
      transform: translateY(0);
    }

    .visualization-grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 2rem;
      margin-top: 1.5rem;
    }

    .canvas-container {
      position: relative;
    }

    .canvas-label {
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.5rem;
    }

    canvas {
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      background: white;
      display: block;
      max-width: 100%;
      height: auto;
    }

    .stats-panel {
      background: linear-gradient(135deg, #f6f8fc 0%, #eef2f7 100%);
      border-radius: 8px;
      padding: 1.5rem;
      border: 1px solid #e2e8f0;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-top: 1rem;
    }

    .stat-item {
      background: white;
      padding: 0.75rem;
      border-radius: 4px;
      border-left: 3px solid #111827;
    }

    .stat-label {
      font-size: 0.8rem;
      color: #718096;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2d3748;
      margin-top: 0.25rem;
    }

    .step-info {
      background: #ebf8ff;
      padding: 1rem;
      border-radius: 4px;
      margin-top: 1rem;
      font-size: 0.9rem;
      color: #2c5282;
    }

    .marginal-plots {
      display: grid;
      gap: 1.5rem;
    }

    .marginal-plot {
      background: #f7fafc;
      padding: 1rem;
      border-radius: 8px;
    }

    @media (max-width: 768px) {
      .visualization-grid {
        grid-template-columns: 1fr;
      }

      .stats-grid {
        grid-template-columns: 1fr;
      }
    }

    .replica-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .replica-canvas-container {
      background: #f7fafc;
      padding: 0.75rem;
      border-radius: 8px;
      border: 2px solid #e2e8f0;
    }

    .replica-label {
      font-weight: 600;
      font-size: 0.9rem;
      color: #2d3748;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .temperature-badge {
      background: #667eea;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
    }
  </style>
</head>

<body>

<!-- Jekyll-style header -->
<header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Jules Perret</a>
    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
          </svg>
        </span>
      </label>
      <div class="trigger">
        <a class="page-link" href="/mcmc_improved.html">MCMC Demo</a>
        <a class="page-link" href="/hmc.html">HMC Demo</a>
        <a class="page-link" href="/nested_sampling.html">Nested Sampling</a>
        <a class="page-link active" href="/parallel_tempering.html">Parallel Tempering</a>
      </div>
    </nav>
  </div>
</header>

<div class="container">
  <h1>Parallel Tempering (Temperature Ladder MCMC)</h1>
  <p class="subtitle">Part 4 of the MCMC Samplers Series ‚Ä¢ Interactive visualization of temperature ladder sampling for multimodal distributions</p>

  <!-- INTRODUCTION -->
  <div class="section">
    <h2 class="section-title">What is Parallel Tempering?</h2>
    <p>
      <strong>Parallel Tempering</strong> (also called <strong>Metropolis-Coupled MCMC</strong> or <strong>MC¬≥</strong>) 
      is a powerful MCMC method designed to overcome the mode-hopping problem in multimodal distributions. The key insight: 
      run multiple MCMC chains simultaneously at different "temperatures," then periodically swap states between chains.
    </p>

    <div class="algorithm-box">
      <strong>The Core Idea:</strong>
      <p style="margin: 0.75rem 0;">
        Instead of sampling from the target posterior \(\pi(\theta)\), run \(K\) parallel chains sampling from 
        "tempered" distributions:
      </p>
      $$\pi_\beta(\theta) \propto \pi(\theta)^\beta = [\mathcal{L}(\theta) \pi_0(\theta)]^\beta$$
      <p style="margin: 0.75rem 0;">
        where \(0 < \beta_K < \beta_{K-1} < \ldots < \beta_2 < \beta_1 = 1\) is the <strong>temperature ladder</strong>:
      </p>
      <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
        <li><strong>\(\beta_1 = 1\):</strong> The "cold" chain samples the true posterior \(\pi(\theta)\)</li>
        <li><strong>\(\beta_k < 1\):</strong> "Hot" chains sample flattened versions (easier to move between modes)</li>
        <li><strong>\(\beta_k \to 0\):</strong> The hottest chain samples almost uniformly (pure exploration)</li>
      </ul>
    </div>

    <div class="info-note">
      <strong>Why does this work?</strong> Hot chains can easily hop between modes because the energy barriers are reduced 
      (think of heating a molecule to make it more mobile). When a hot chain discovers a new mode, it can swap states 
      with cooler chains, eventually transferring this information to the cold chain that targets the true posterior. 
      This creates an <strong>efficient exploration-exploitation trade-off</strong>.
    </div>
  </div>

  <!-- ALGORITHM -->
  <div class="section">
    <h2 class="section-title">The Algorithm</h2>
    <p>
      Parallel tempering alternates between two steps: <strong>local MCMC moves</strong> within each chain and 
      <strong>replica exchange swaps</strong> between adjacent temperatures.
    </p>

    <div class="algorithm-box">
      <strong>Algorithm: Parallel Tempering</strong>
      <ol style="margin: 0.75rem 0; padding-left: 1.5rem; line-height: 1.8;">
        <li><strong>Initialize:</strong> Set up \(K\) chains, each at temperature \(\beta_k\), with initial states \(\theta^{(k)}\)</li>
        <li><strong>MCMC step:</strong> For each chain \(k = 1, \ldots, K\):
          <ul style="padding-left: 1.5rem;">
            <li>Propose \(\theta' \sim q(\cdot \mid \theta^{(k)})\) using Metropolis-Hastings</li>
            <li>Accept with probability \(\alpha = \min(1, r^{\beta_k})\) where \(r = \frac{\pi(\theta')}{\pi(\theta^{(k)})}\)</li>
          </ul>
        </li>
        <li><strong>Exchange step:</strong> For each adjacent pair \((k, k+1)\):
          <ul style="padding-left: 1.5rem;">
            <li>Propose to swap states: \(\theta^{(k)} \leftrightarrow \theta^{(k+1)}\)</li>
            <li>Accept swap with probability:
              $$\alpha_{\text{swap}} = \min\left(1, \frac{\pi(\theta^{(k)})^{\beta_{k+1}} \pi(\theta^{(k+1)})^{\beta_k}}{\pi(\theta^{(k)})^{\beta_k} \pi(\theta^{(k+1)})^{\beta_{k+1}}}\right)$$
              which simplifies to:
              $$\alpha_{\text{swap}} = \min\left(1, \exp\left[(\beta_k - \beta_{k+1})(\log \pi(\theta^{(k)}) - \log \pi(\theta^{(k+1)}))\right]\right)$$
            </li>
          </ul>
        </li>
        <li><strong>Repeat:</strong> Iterate steps 2-3. Collect samples from the cold chain (\(\beta_1 = 1\)) only</li>
      </ol>
    </div>

    <div class="info-note">
      <strong>Key insight on the swap acceptance:</strong> The swap is more likely when states have similar posteriors, 
      or when temperatures are close together. This motivates careful design of the temperature ladder to ensure 
      good "communication" between chains. A common target is 20-40% swap acceptance between adjacent temperatures.
    </div>
  </div>

  <!-- TARGET DISTRIBUTIONS -->
  <div class="section">
    <h2 class="section-title">Target Distributions</h2>
    <p>
      We provide four distributions to illustrate parallel tempering's strengths and compare with standard MCMC:
    </p>
    
    <div style="display: grid; grid-template-columns: 1fr; gap: 1.5rem; margin-top: 1rem;">
      <div class="algorithm-box">
        <strong>Bivariate Gaussian (Baseline)</strong>
        <p style="margin: 0.5rem 0;">
          A standard correlated 2D Gaussian with \(\rho = 0.8\). Single mode‚Äîparallel tempering is overkill here, 
          but useful to understand temperature effects.
        </p>
      </div>

      <div class="algorithm-box" style="background: #fef3c7; border-left: 4px solid #f59e0b;">
        <strong>üåü Bimodal Gaussian Mixture (Perfect for PT!)</strong>
        <p style="margin: 0.5rem 0;">
          Two well-separated modes at (-2,-2) and (+2,+2):
        </p>
        $$\pi(\theta) = 0.4 \cdot \mathcal{N}((-2,-2), 0.8^2I) + 0.6 \cdot \mathcal{N}((+2,+2), 0.8^2I)$$
        <p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #78350f;">
          <strong>This is where PT shines!</strong> Standard MH gets stuck in one mode. Hot chains easily hop between modes, 
          and swaps propagate this information to the cold chain. Watch how different temperature chains explore differently!
        </p>
      </div>

      <div class="algorithm-box">
        <strong>Rosenbrock's Banana</strong>
        <p style="margin: 0.5rem 0;">
          Strongly correlated along a curved manifold. Single mode but challenging geometry. PT helps but HMC is better here.
        </p>
      </div>

      <div class="algorithm-box">
        <strong>Neal's Funnel</strong>
        <p style="margin: 0.5rem 0;">
          Hierarchical model with exponentially varying scales. Hot chains can explore the narrow neck more easily. 
          PT helps, but the real solution is reparameterization or HMC.
        </p>
      </div>
    </div>
  </div>

  <!-- CONTROLS -->
  <div class="section">
    <h2 class="section-title">Simulation Controls</h2>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
      <div class="control-group">
        <label>
          Target Distribution
        </label>
        <select id="dist">
          <option value="gaussian">Bivariate Gaussian</option>
          <option value="bimodal" selected>Bimodal Mixture (‚òÖ Best for PT!)</option>
          <option value="banana">Rosenbrock's Banana</option>
          <option value="funnel">Neal's Funnel</option>
        </select>
      </div>

      <div class="control-group">
        <label>
          Number of Temperatures: <span id="numTempsValue">4</span>
        </label>
        <input type="range" id="numTemps" min="2" max="8" value="4" step="1">
        <div style="font-size: 0.85rem; color: #4a5568; margin-top: 0.25rem;">
          More temperatures = better exploration but higher computational cost
        </div>
      </div>

      <div class="control-group">
        <label>
          Temperature Spacing: <span id="tempSpacingValue">Geometric (Œ≤ = 0.2^(k-1))</span>
        </label>
        <input type="range" id="tempSpacing" min="1" max="4" value="2" step="1">
        <div style="font-size: 0.85rem; color: #4a5568; margin-top: 0.25rem;">
          Controls how quickly temperatures decrease
        </div>
      </div>

      <div class="control-group">
        <label>
          Iterations per Swap: <span id="swapFreqValue">10</span>
        </label>
        <input type="range" id="swapFreq" min="1" max="50" value="10" step="1">
        <div style="font-size: 0.85rem; color: #4a5568; margin-top: 0.25rem;">
          Number of MCMC steps between swap attempts
        </div>
      </div>

      <div class="control-group">
        <label>
          Iteration Speed (ms)
          <span class="control-value" id="speedVal">50</span>
        </label>
        <input type="range" min="10" max="500" step="10" value="50" id="speed">
        <div style="font-size: 0.85rem; color: #4a5568; margin-top: 0.25rem;">
          Delay between iterations. Slower speeds help visualize swaps.
        </div>
      </div>
    </div>

    <div class="button-group">
      <button onclick="start()">‚ñ∂ Start Sampling</button>
      <button class="secondary" onclick="singleStep()">‚Üí Single Step</button>
      <button class="secondary" onclick="reset()">‚Üª Reset</button>
    </div>
  </div>

  <!-- VISUALIZATION -->
  <div class="section">
    <h2 class="section-title">Temperature Chain Visualizations</h2>
    <p>
      Each subplot shows one temperature level in the ladder. <strong>Chain 1 (top-left, Œ≤=1.0)</strong> always samples 
      the true posterior‚Äîthis is your target chain. <strong>Hotter chains (lower Œ≤)</strong> sample flattened distributions 
      and explore more freely. 
    </p>
    <p style="margin-top: 0.5rem;">
      <strong>How swaps work:</strong> States (the x,y positions) move between chains, but each chain position keeps its 
      temperature. When you see a point jump, that's a state moving from one temperature to another. The cold chain 
      (position 1) receives information about newly discovered modes from the hot chains through these swaps.
    </p>
    
    <div id="replicaGrid" class="replica-grid">
      <!-- Dynamically populated based on number of temperatures -->
    </div>
  </div>

  <!-- DIAGNOSTICS -->
  <div class="section">
    <h2 class="section-title">Parallel Tempering Diagnostics</h2>
    <p>
      The key diagnostics for PT are: <strong>swap acceptance rates</strong> (are chains communicating well?), 
      <strong>chain exploration</strong> (is each temperature exploring its target properly?), and 
      <strong>cold chain coverage</strong> (does the final posterior sample all modes correctly?).
    </p>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 1.5rem;">
      <div>
        <div class="canvas-label">Swap Acceptance Rate Between Adjacent Chains</div>
        <canvas id="swapAcceptance" width="100%" height="40" style="width: 100%;"></canvas>
        <p style="font-size: 0.85rem; color: #4a5568; margin-top: 0.5rem;">
          <strong>Target: 20-40%.</strong> Green = optimal, Orange = acceptable, Red = problematic.
        </p>
      </div>

      <div>
        <div class="canvas-label">Cold Chain Trace Plot (Œ∏‚ÇÅ)</div>
        <canvas id="tracePlot" width="100%" height="40" style="width: 100%;"></canvas>
        <p style="font-size: 0.85rem; color: #4a5568; margin-top: 0.5rem;">
          Chain 1 (Œ≤=1.0) position over time. Good mixing shows random walk behavior with mode switches.
        </p>
      </div>
    </div>
  </div>

  <!-- CONVERGENCE DIAGNOSTICS -->
  <div class="section">
    <h2 class="section-title">Convergence Diagnostics</h2>
    <p>
      Unlike single-chain MCMC, parallel tempering convergence depends on both <strong>within-chain mixing</strong> 
      (each chain exploring its target) and <strong>between-chain communication</strong> (swaps transferring information). 
      Watch for the burn-in phase where chains move from initial positions to the target distribution.
    </p>

    <div style="margin-top: 1.5rem;">
      <div class="canvas-label">Cold Chain (Œ≤=1.0) - Both Coordinates Over Time</div>
      <canvas id="bothCoordinates" width="100%" height="40" style="width: 100%;"></canvas>
      <p style="font-size: 0.85rem; color: #4a5568; margin-top: 0.5rem;">
        <strong>Œ∏‚ÇÅ (blue)</strong> and <strong>Œ∏‚ÇÇ (orange)</strong> vs iteration for the cold chain. 
        Look for: (1) <strong>Burn-in</strong> - initial transient behavior as chain moves from random start to posterior, 
        (2) <strong>Stationarity</strong> - stable wandering within posterior region, 
        (3) <strong>Mode switching</strong> - for bimodal, jumps between (-2,-2) and (+2,+2) regions.
      </p>
    </div>

    <div class="info-note" style="margin-top: 1.5rem;">
      <strong>Assessing Convergence:</strong>
      <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
        <li><strong>Burn-in phase:</strong> First ~50-200 iterations as chains move from random initialization. 
        Discard these when analyzing posterior.</li>
        <li><strong>Within-chain mixing:</strong> Trace plots should show random fluctuations without trends or getting stuck.</li>
        <li><strong>Between-chain communication:</strong> Swap acceptance rates of 20-40% ensure information flows between temperatures.</li>
        <li><strong>Mode exploration (multimodal):</strong> Cold chain should visit all modes. Count transitions between modes in trace plot.</li>
        <li><strong>Visual check:</strong> Does the cold chain posterior coverage match the true distribution? Run longer if modes are missing.</li>
      </ul>
    </div>
  </div>

  <!-- COLD CHAIN FINAL POSTERIOR -->
  <div class="section">
    <h2 class="section-title">Cold Chain Final Posterior</h2>
    <p>
      This is the payoff: samples from Chain 1 (Œ≤=1.0) represent the true posterior after discarding burn-in.
    </p>

    <div style="margin-top: 1.5rem;">
      <div class="canvas-label">Cold Chain (Œ≤=1.0) - True Posterior Samples</div>
      <canvas id="coldChainPosterior" width="400" height="400" style="max-width: 100%;"></canvas>
      <p style="font-size: 0.85rem; color: #4a5568; margin-top: 0.5rem;">
        <strong>This is what matters!</strong> Only samples from the cold chain (Chain 1, Œ≤=1.0) represent the true posterior. 
        For the bimodal distribution: both modes should be explored proportionally to their weights (40% and 60%). 
        If only one mode appears, parallel tempering isn't helping (try more chains or better temperature spacing).
      </p>
    </div>
  </div>

  <!-- PERFORMANCE STATS -->
  <div class="section">
    <h2 class="section-title">Performance Metrics</h2>
    <div class="stats-grid">
      <div class="stat-item">
        <div class="stat-label">Total Iterations</div>
        <div class="stat-value" id="totalIter">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Cold Chain Samples</div>
        <div class="stat-value" id="coldSamples">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Swap Attempts</div>
        <div class="stat-value" id="swapAttempts">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Successful Swaps</div>
        <div class="stat-value" id="swapAccepts">0</div>
      </div>
    </div>

    <div class="info-note" style="margin-top: 1.5rem;">
      <strong>Understanding the metrics:</strong>
      <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
        <li><strong>Total Iterations:</strong> MCMC steps √ó number of chains (each chain moves every iteration)</li>
        <li><strong>Cold Chain Samples:</strong> Number of posterior samples (one per iteration from Chain 1)</li>
        <li><strong>Swap Success Rate:</strong> Proportion of accepted swaps (should be 20-40% per adjacent pair)</li>
        <li><strong>Computational Cost:</strong> PT requires K√ó more likelihood evaluations than standard MCMC</li>
      </ul>
    </div>

    <div id="stepInfo" class="step-info">
      Click "Start Sampling" to begin parallel tempering.
    </div>
  </div>

  <!-- STRENGTHS AND LIMITATIONS -->
  <div class="section">
    <h2 class="section-title">Strengths & Limitations</h2>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-top: 1rem;">
      <div class="algorithm-box">
        <strong style="color: #059669;">‚úì Strengths</strong>
        <ul style="margin: 0.75rem 0 0 0; padding-left: 1.5rem;">
          <li style="margin: 0.5rem 0;"><strong>Multimodality:</strong> Excellent for exploring multiple well-separated modes</li>
          <li style="margin: 0.5rem 0;"><strong>Mode discovery:</strong> Hot chains find modes; swaps propagate to cold chain</li>
          <li style="margin: 0.5rem 0;"><strong>Correct weights:</strong> Unlike simulated annealing, maintains detailed balance</li>
          <li style="margin: 0.5rem 0;"><strong>Embarrassingly parallel:</strong> Each chain runs independently between swaps</li>
          <li style="margin: 0.5rem 0;"><strong>Gradient-free:</strong> Works when gradients unavailable (unlike HMC)</li>
        </ul>
      </div>
      
      <div class="algorithm-box">
        <strong style="color: #dc2626;">‚úó Limitations</strong>
        <ul style="margin: 0.75rem 0 0 0; padding-left: 1.5rem;">
          <li style="margin: 0.5rem 0;"><strong>Computational cost:</strong> \(K\) chains means \(K\times\) function evaluations</li>
          <li style="margin: 0.5rem 0;"><strong>Temperature ladder design:</strong> Requires careful tuning for efficiency</li>
          <li style="margin: 0.5rem 0;"><strong>High dimensions:</strong> Swap acceptance decreases exponentially with \(d\)</li>
          <li style="margin: 0.5rem 0;"><strong>Not for all problems:</strong> Overkill for unimodal posteriors (use HMC instead)</li>
          <li style="margin: 0.5rem 0;"><strong>Memory overhead:</strong> Must store \(K\) states simultaneously</li>
        </ul>
      </div>
    </div>

    <div class="info-note" style="margin-top: 1.5rem;">
      <strong>When to use Parallel Tempering:</strong>
      <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
        <li>Multimodal posteriors with well-separated modes (physical phase transitions, mixture models)</li>
        <li>Rugged energy landscapes (statistical mechanics, protein folding)</li>
        <li>When you suspect multiple modes but don't know how many</li>
        <li>When gradients are unavailable (unlike HMC) but you have computational budget</li>
        <li>Dimensions \(d \lesssim 20\) (swap acceptance degrades in high-d)</li>
      </ul>
    </div>
  </div>

  <!-- COMPARISON -->
  <div class="section">
    <h2 class="section-title">Comparison with Other Methods</h2>
    
    <div class="algorithm-box">
      <table style="width: 100%; border-collapse: collapse;">
        <tr style="border-bottom: 2px solid #e2e8f0;">
          <th style="text-align: left; padding: 0.75rem;">Property</th>
          <th style="text-align: left; padding: 0.75rem;">Standard MH</th>
          <th style="text-align: left; padding: 0.75rem;">HMC</th>
          <th style="text-align: left; padding: 0.75rem;">Parallel Tempering</th>
          <th style="text-align: left; padding: 0.75rem;">Nested Sampling</th>
        </tr>
        <tr style="border-bottom: 1px solid #e2e8f0;">
          <td style="padding: 0.75rem;">Multimodality</td>
          <td style="padding: 0.75rem;">Poor (stuck)</td>
          <td style="padding: 0.75rem;">Poor (stuck)</td>
          <td style="padding: 0.75rem;"><strong>Excellent</strong></td>
          <td style="padding: 0.75rem;"><strong>Excellent</strong></td>
        </tr>
        <tr style="border-bottom: 1px solid #e2e8f0;">
          <td style="padding: 0.75rem;">High dimensions</td>
          <td style="padding: 0.75rem;">Poor</td>
          <td style="padding: 0.75rem;"><strong>Excellent</strong></td>
          <td style="padding: 0.75rem;">Poor (swap rate ‚Üì)</td>
          <td style="padding: 0.75rem;">Poor (curse of d)</td>
        </tr>
        <tr style="border-bottom: 1px solid #e2e8f0;">
          <td style="padding: 0.75rem;">Gradient-free?</td>
          <td style="padding: 0.75rem;">Yes</td>
          <td style="padding: 0.75rem;">No</td>
          <td style="padding: 0.75rem;">Yes</td>
          <td style="padding: 0.75rem;">Yes</td>
        </tr>
        <tr style="border-bottom: 1px solid #e2e8f0;">
          <td style="padding: 0.75rem;">Computes evidence?</td>
          <td style="padding: 0.75rem;">No</td>
          <td style="padding: 0.75rem;">No</td>
          <td style="padding: 0.75rem;">No</td>
          <td style="padding: 0.75rem;"><strong>Yes</strong></td>
        </tr>
        <tr>
          <td style="padding: 0.75rem;">Computational cost</td>
          <td style="padding: 0.75rem;">Low (1√ó)</td>
          <td style="padding: 0.75rem;">Medium (gradient)</td>
          <td style="padding: 0.75rem;"><strong>High (\(K\)√ó)</strong></td>
          <td style="padding: 0.75rem;">Medium-High</td>
        </tr>
      </table>
    </div>

    <p style="margin-top: 1rem;">
      <strong>Practical recommendation:</strong> Use PT for low-to-moderate dimensional multimodal problems without gradients. 
      Use HMC/NUTS for high-dimensional unimodal posteriors with gradients. Use nested sampling when you need evidence 
      (model comparison) or for multimodal problems in very low dimensions.
    </p>
  </div>

  <!-- REFERENCES -->
  <div class="section">
    <h2 class="section-title">References & Further Reading</h2>
    <div style="font-size: 0.9rem; line-height: 1.8;">
      <p><strong>Key Papers:</strong></p>
      <ul style="padding-left: 1.5rem; margin: 0.5rem 0;">
        <li>Geyer, C.J. (1991). "Markov Chain Monte Carlo Maximum Likelihood." 
        In <em>Computing Science and Statistics: Proceedings of the 23rd Symposium on the Interface</em>, 156-163.</li>
        <li>Hukushima, K., & Nemoto, K. (1996). "Exchange Monte Carlo Method and Application to Spin Glass Simulations." 
        <em>Journal of the Physical Society of Japan</em>, 65(6), 1604-1608.</li>
        <li>Earl, D.J., & Deem, M.W. (2005). "Parallel Tempering: Theory, Applications, and New Perspectives." 
        <em>Physical Chemistry Chemical Physics</em>, 7(23), 3910-3916.</li>
        <li>Swendsen, R.H., & Wang, J.S. (1986). "Replica Monte Carlo Simulation of Spin-Glasses." 
        <em>Physical Review Letters</em>, 57(21), 2607-2609. (Original replica exchange idea)</li>
        <li>Katzgraber, H.G., Trebst, S., Huse, D.A., & Troyer, M. (2006). "Feedback-Optimized Parallel Tempering Monte Carlo." 
        <em>Journal of Statistical Mechanics: Theory and Experiment</em>, 2006(03), P03018.</li>
      </ul>
      
      <p style="margin-top: 1rem;"><strong>Temperature Ladder Design:</strong></p>
      <ul style="padding-left: 1.5rem; margin: 0.5rem 0;">
        <li>Kone, A., & Kofke, D.A. (2005). "Selection of Temperature Intervals for Parallel-Tempering Simulations." 
        <em>Journal of Chemical Physics</em>, 122(20), 206101.</li>
        <li>Rathore, N., Chopra, M., & de Pablo, J.J. (2005). "Optimal Allocation of Replicas in Parallel Tempering Simulations." 
        <em>Journal of Chemical Physics</em>, 122(2), 024111.</li>
      </ul>
      
      <p style="margin-top: 1rem;"><strong>Books:</strong></p>
      <ul style="padding-left: 1.5rem; margin: 0.5rem 0;">
        <li>Brooks, S., Gelman, A., Jones, G., & Meng, X.-L. (2011). <em>Handbook of Markov Chain Monte Carlo</em>. 
        CRC Press. (Chapter 7: Parallel and Interacting Chains)</li>
        <li>Liu, J.S. (2001). <em>Monte Carlo Strategies in Scientific Computing</em>. Springer. 
        (Chapter 6: Simulated Tempering and Related Methods)</li>
      </ul>
      
      <p style="margin-top: 1rem;"><strong>Software:</strong></p>
      <ul style="padding-left: 1.5rem; margin: 0.5rem 0;">
        <li><strong>emcee:</strong> Python - The MCMC Hammer (includes parallel tempering as PTSampler)</li>
        <li><strong>PyMC:</strong> Can implement PT with custom samplers</li>
        <li><strong>PTEMCEE:</strong> Parallel-tempered ensemble MCMC in Python</li>
        <li><strong>MrBayes:</strong> Phylogenetics software with Metropolis-Coupled MCMC (MC¬≥)</li>
      </ul>
    </div>
  </div>

</div>

<script>
/***************************************************
 * CANVAS & UI SETUP
 ***************************************************/
const replicaGrid = document.getElementById("replicaGrid");
const swapAcceptanceCanvas = document.getElementById("swapAcceptance");
const tracePlotCanvas = document.getElementById("tracePlot");
const bothCoordinatesCanvas = document.getElementById("bothCoordinates");
const coldChainCanvas = document.getElementById("coldChainPosterior");

const swapAcceptanceCtx = swapAcceptanceCanvas.getContext("2d");
const tracePlotCtx = tracePlotCanvas.getContext("2d");
const bothCoordinatesCtx = bothCoordinatesCanvas.getContext("2d");
const coldChainCtx = coldChainCanvas.getContext("2d");

// Scale canvases for retina
function scaleCanvas(canvas) {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext("2d");
  ctx.scale(dpr, dpr);
  canvas.style.width = rect.width + "px";
  canvas.style.height = rect.height + "px";
}

scaleCanvas(swapAcceptanceCanvas);
scaleCanvas(tracePlotCanvas);
scaleCanvas(bothCoordinatesCanvas);
scaleCanvas(coldChainCanvas);

/***************************************************
 * PARAMETERS & STATE
 ***************************************************/
let xmin = -4, xmax = 4, ymin = -4, ymax = 4;
let numTemperatures = 4;
let temperatures = []; // Œ≤ values
let swapFrequency = 10;
let iteration = 0;
let swapIteration = 0;
let running = false;
let animDelay = 50; // milliseconds, matches default slider value

// Replica state: array of {x, y, beta, samples: [{x, y}], accepts: 0, proposals: 0}
let replicas = [];

// Swap statistics: swapAccepts[k] = accepts between k and k+1, swapAttempts[k] = attempts
let swapAccepts = [];
let swapAttempts = [];

// Cold chain samples (only from Chain 1 which has beta=1.0)
let coldSamples = [];

// Replica canvases
let replicaCanvases = [];
let replicaContexts = [];

/***************************************************
 * UI CONTROLS
 ***************************************************/
document.getElementById("numTemps").addEventListener("input", (e) => {
  numTemperatures = parseInt(e.target.value);
  document.getElementById("numTempsValue").textContent = numTemperatures;
  if (!running) {
    setupTemperatures();
    reset();
  }
});

document.getElementById("tempSpacing").addEventListener("input", (e) => {
  const val = parseInt(e.target.value);
  const spacings = ["Linear", "Geometric", "Exponential", "Adaptive"];
  document.getElementById("tempSpacingValue").textContent = spacings[val - 1];
  if (!running) {
    setupTemperatures();
    reset();
  }
});

document.getElementById("swapFreq").addEventListener("input", (e) => {
  swapFrequency = parseInt(e.target.value);
  document.getElementById("swapFreqValue").textContent = swapFrequency;
});

document.getElementById("speed").addEventListener("input", (e) => {
  animDelay = parseInt(e.target.value);
  document.getElementById("speedVal").textContent = animDelay;
});

document.getElementById("dist").addEventListener("change", () => {
  setDomain();
  reset();
});

/***************************************************
 * TEMPERATURE LADDER SETUP
 ***************************************************/
function setupTemperatures() {
  const spacingType = parseInt(document.getElementById("tempSpacing").value);
  temperatures = [];
  
  // Always have cold chain at beta=1.0
  if (spacingType === 1) {
    // Linear spacing
    for (let k = 0; k < numTemperatures; k++) {
      temperatures.push(1.0 - k * 0.8 / (numTemperatures - 1));
    }
  } else if (spacingType === 2) {
    // Geometric spacing (good default)
    const ratio = Math.pow(0.2, 1.0 / (numTemperatures - 1));
    for (let k = 0; k < numTemperatures; k++) {
      temperatures.push(Math.pow(ratio, k));
    }
  } else if (spacingType === 3) {
    // Exponential spacing (more aggressive)
    for (let k = 0; k < numTemperatures; k++) {
      temperatures.push(Math.exp(-2.0 * k / (numTemperatures - 1)));
    }
  } else {
    // Adaptive (aim for ~30% acceptance between adjacent)
    // For demo, use geometric as approximation
    const ratio = Math.pow(0.15, 1.0 / (numTemperatures - 1));
    for (let k = 0; k < numTemperatures; k++) {
      temperatures.push(Math.pow(ratio, k));
    }
  }
  
  // Ensure cold chain is exactly 1.0
  temperatures[0] = 1.0;
}

/***************************************************
 * TARGET DISTRIBUTIONS
 ***************************************************/
function setDomain() {
  const type = document.getElementById("dist").value;
  if (type === "funnel") {
    xmin = -10; xmax = 10;
    ymin = -50; ymax = 50;
  } else if (type === "banana") {
    xmin = -3; xmax = 3;
    ymin = -1; ymax = 8;
  } else if (type === "bimodal") {
    xmin = -5; xmax = 5;
    ymin = -5; ymax = 5;
  } else {
    xmin = -4; xmax = 4;
    ymin = -4; ymax = 4;
  }
}

function target(x, y) {
  const type = document.getElementById("dist").value;
  if (type === "funnel") return targetFunnel(x, y);
  if (type === "banana") return targetBanana(x, y);
  if (type === "bimodal") return targetBimodal(x, y);
  return targetGaussian(x, y);
}

function targetGaussian(x, y) {
  const rho = 0.8;
  const exponent = (x*x - 2*rho*x*y + y*y) / (2 * (1 - rho*rho));
  return Math.exp(-exponent);
}

function targetBanana(x, y) {
  const exponent = (x*x + 100 * (y - x*x)**2) / 200;
  return Math.exp(-exponent);
}

function targetFunnel(x, y) {
  const ex = Math.exp(x);
  const exponent = x*x / 18 + y*y / (2 * ex * ex);
  return Math.exp(-exponent);
}

function targetBimodal(x, y) {
  const sigma = 0.8;
  const dx1 = x + 2, dy1 = y + 2;
  const mode1 = 0.4 * Math.exp(-(dx1*dx1 + dy1*dy1) / (2 * sigma*sigma));
  const dx2 = x - 2, dy2 = y - 2;
  const mode2 = 0.6 * Math.exp(-(dx2*dx2 + dy2*dy2) / (2 * sigma*sigma));
  return mode1 + mode2;
}

/***************************************************
 * INITIALIZATION
 ***************************************************/
function reset() {
  running = false;
  iteration = 0;
  swapIteration = 0;
  coldSamples = [];
  
  setupTemperatures();
  
  // Initialize chains
  replicas = [];
  swapAccepts = Array(numTemperatures - 1).fill(0);
  swapAttempts = Array(numTemperatures - 1).fill(0);
  
  for (let k = 0; k < numTemperatures; k++) {
    replicas.push({
      x: (Math.random() - 0.5) * (xmax - xmin),
      y: (Math.random() - 0.5) * (ymax - ymin),
      beta: temperatures[k],
      samples: [],
      accepts: 0,
      proposals: 0,
      index: k // Track original temperature index
    });
  }
  
  // Create replica canvases
  replicaGrid.innerHTML = "";
  replicaCanvases = [];
  replicaContexts = [];
  
  for (let k = 0; k < numTemperatures; k++) {
    const container = document.createElement("div");
    container.className = "replica-canvas-container";
    
    const label = document.createElement("div");
    label.className = "replica-label";
    label.innerHTML = `
      <span>Chain ${k + 1}</span>
      <span class="temperature-badge">Œ≤ = ${temperatures[k].toFixed(3)}</span>
    `;
    
    const canvas = document.createElement("canvas");
    canvas.width = 280;
    canvas.height = 280;
    canvas.style.width = "100%";
    canvas.style.height = "auto";
    
    container.appendChild(label);
    container.appendChild(canvas);
    replicaGrid.appendChild(container);
    
    replicaCanvases.push(canvas);
    replicaContexts.push(canvas.getContext("2d"));
  }
  
  updateStats();
  drawAll();
  
  document.getElementById("stepInfo").textContent = "Ready. Click 'Start Sampling' to begin.";
}

/***************************************************
 * MCMC STEP FOR EACH CHAIN
 ***************************************************/
function mcmcStep() {
  for (let k = 0; k < numTemperatures; k++) {
    const replica = replicas[k];
    const beta = replica.beta;
    
    // Proposal (simple random walk)
    const sigma = 0.3;
    const xprop = replica.x + sigma * (Math.random() - 0.5) * 2;
    const yprop = replica.y + sigma * (Math.random() - 0.5) * 2;
    
    // Compute acceptance with temperature
    const curr_pi = target(replica.x, replica.y);
    const prop_pi = target(xprop, yprop);
    
    const ratio = Math.pow(prop_pi / curr_pi, beta);
    const accept = Math.random() < Math.min(1, ratio);
    
    replica.proposals++;
    if (accept) {
      replica.x = xprop;
      replica.y = yprop;
      replica.accepts++;
    }
    
    // Store sample in this chain's trajectory
    replica.samples.push({x: replica.x, y: replica.y});
  }
  
  // CRITICAL: Always collect from replicas[0] which has beta=1.0
  // After swaps, different states visit this position, but it always has beta=1.0
  coldSamples.push({x: replicas[0].x, y: replicas[0].y});
}

/***************************************************
 * CHAIN SWAPS (State Exchange)
 ***************************************************/
function replicaExchange() {
  // Try swaps between adjacent temperatures
  for (let k = 0; k < numTemperatures - 1; k++) {
    const r1 = replicas[k];
    const r2 = replicas[k + 1];
    
    swapAttempts[k]++;
    
    const pi1 = target(r1.x, r1.y);
    const pi2 = target(r2.x, r2.y);
    
    // Swap acceptance probability
    const deltaL = Math.log(Math.max(pi1, 1e-300)) - Math.log(Math.max(pi2, 1e-300));
    const deltaBeta = r1.beta - r2.beta;
    const logAccept = deltaBeta * deltaL;
    
    if (Math.random() < Math.exp(logAccept)) {
      // Accept swap - exchange STATE (positions) but NOT temperatures
      // The temperatures stay with their array positions
      const tmpX = r1.x, tmpY = r1.y;
      r1.x = r2.x;
      r1.y = r2.y;
      r2.x = tmpX;
      r2.y = tmpY;
      
      swapAccepts[k]++;
    }
  }
  
  swapIteration++;
}

/***************************************************
 * SINGLE STEP
 ***************************************************/
function singleStep() {
  mcmcStep();
  iteration++;
  
  // Check if it's time for replica exchange
  if (iteration % swapFrequency === 0) {
    replicaExchange();
  }
  
  updateStats();
  drawAll();
}

/***************************************************
 * CONTINUOUS SAMPLING
 ***************************************************/
async function start() {
  if (running) {
    running = false;
    return;
  }
  
  running = true;
  const button = event.target;
  button.textContent = "‚è∏ Pause";
  
  while (running) {
    singleStep();
    await new Promise(resolve => setTimeout(resolve, animDelay));
  }
  
  button.textContent = "‚ñ∂ Start Sampling";
}

/***************************************************
 * DRAWING
 ***************************************************/
function drawAll() {
  drawReplicas();
  drawSwapAcceptance();
  drawTracePlot();
  drawBothCoordinates();
  drawColdChain();
}

function drawReplicas() {
  for (let k = 0; k < numTemperatures; k++) {
    const ctx = replicaContexts[k];
    const canvas = replicaCanvases[k];
    const replica = replicas[k];
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw contours (lighter for hot chains)
    drawContour(ctx, canvas, replica.beta);
    
    // Draw trajectory
    const samples = replica.samples;
    if (samples.length > 1) {
      ctx.strokeStyle = `rgba(59, 130, 246, ${0.3 + 0.4 * replica.beta})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let i = 0; i < samples.length; i++) {
        const [cx, cy] = toCanvasReplica(samples[i].x, samples[i].y, canvas);
        if (i === 0) ctx.moveTo(cx, cy);
        else ctx.lineTo(cx, cy);
      }
      ctx.stroke();
    }
    
    // Draw current position
    const [cx, cy] = toCanvasReplica(replica.x, replica.y, canvas);
    ctx.fillStyle = replica.beta === 1.0 ? "#dc2626" : "#3b82f6";
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, 2 * Math.PI);
    ctx.fill();
    
    // Draw acceptance rate
    const accRate = replica.proposals > 0 ? (replica.accepts / replica.proposals * 100).toFixed(1) : 0;
    ctx.fillStyle = "#2d3748";
    ctx.font = "11px monospace";
    ctx.fillText(`Acc: ${accRate}%`, 5, canvas.height - 5);
  }
}

function drawContour(ctx, canvas, beta) {
  const w = canvas.width;
  const h = canvas.height;
  const imageData = ctx.createImageData(w, h);
  const data = imageData.data;
  
  let maxZ = 0;
  const zValues = [];
  
  // Compute all z values
  for (let j = 0; j < h; j++) {
    zValues[j] = [];
    for (let i = 0; i < w; i++) {
      const x = xmin + (i / w) * (xmax - xmin);
      const y = ymax - (j / h) * (ymax - ymin);
      const z = Math.pow(target(x, y), beta);
      zValues[j][i] = z;
      if (z > maxZ) maxZ = z;
    }
  }
  
  // Fill pixels
  for (let j = 0; j < h; j++) {
    for (let i = 0; i < w; i++) {
      const idx = (j * w + i) * 4;
      const normalized = maxZ > 0 ? zValues[j][i] / maxZ : 0;
      const intensity = Math.floor(255 * (1 - normalized * 0.7));
      data[idx] = intensity;
      data[idx + 1] = intensity;
      data[idx + 2] = intensity;
      data[idx + 3] = 255;
    }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function toCanvasReplica(x, y, canvas) {
  const cx = (x - xmin) / (xmax - xmin) * canvas.width;
  const cy = (ymax - y) / (ymax - ymin) * canvas.height;
  return [cx, cy];
}

function drawSwapAcceptance() {
  const ctx = swapAcceptanceCtx;
  const canvas = swapAcceptanceCanvas;
  const w = canvas.getBoundingClientRect().width;
  const h = canvas.getBoundingClientRect().height;
  
  ctx.clearRect(0, 0, w, h);
  
  if (numTemperatures < 2) return;
  
  const margin = {top: 20, right: 20, bottom: 40, left: 50};
  const plotW = w - margin.left - margin.right;
  const plotH = h - margin.top - margin.bottom;
  
  // Draw grid
  ctx.strokeStyle = "#e2e8f0";
  ctx.lineWidth = 1;
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + i / 5 * plotH;
    ctx.beginPath();
    ctx.moveTo(margin.left, y);
    ctx.lineTo(margin.left + plotW, y);
    ctx.stroke();
  }
  
  // Draw target range (20-40%)
  ctx.fillStyle = "rgba(72, 187, 120, 0.1)";
  const y20 = margin.top + (1 - 0.2) * plotH;
  const y40 = margin.top + (1 - 0.4) * plotH;
  ctx.fillRect(margin.left, y40, plotW, y20 - y40);
  
  // Draw bars
  const barWidth = plotW / (numTemperatures - 1) * 0.6;
  for (let k = 0; k < numTemperatures - 1; k++) {
    const rate = swapAttempts[k] > 0 ? swapAccepts[k] / swapAttempts[k] : 0;
    const x = margin.left + (k / (numTemperatures - 1)) * plotW;
    const barH = rate * plotH;
    const y = margin.top + plotH - barH;
    
    // Color based on rate
    if (rate < 0.1 || rate > 0.5) {
      ctx.fillStyle = "#f56565";
    } else if (rate >= 0.2 && rate <= 0.4) {
      ctx.fillStyle = "#48bb78";
    } else {
      ctx.fillStyle = "#ed8936";
    }
    
    ctx.fillRect(x - barWidth / 2, y, barWidth, barH);
  }
  
  // Axes
  ctx.strokeStyle = "#2d3748";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + plotH);
  ctx.lineTo(margin.left + plotW, margin.top + plotH);
  ctx.stroke();
  
  // Labels
  ctx.fillStyle = "#2d3748";
  ctx.font = "12px -apple-system, sans-serif";
  ctx.textAlign = "center";
  for (let k = 0; k < numTemperatures - 1; k++) {
    const x = margin.left + (k / (numTemperatures - 1)) * plotW;
    ctx.fillText(`${k + 1}-${k + 2}`, x, h - 15);
  }
  
  ctx.textAlign = "right";
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + (1 - i / 5) * plotH;
    ctx.fillText(`${(i / 5 * 100).toFixed(0)}%`, margin.left - 5, y + 4);
  }
  
  ctx.font = "bold 12px -apple-system, sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("Temperature Pair", w / 2, h - 2);
}

function drawTracePlot() {
  const ctx = tracePlotCtx;
  const canvas = tracePlotCanvas;
  const w = canvas.getBoundingClientRect().width;
  const h = canvas.getBoundingClientRect().height;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  if (coldSamples.length < 2) return;
  
  const margin = {top: 20, right: 20, bottom: 40, left: 50};
  const plotW = w - margin.left - margin.right;
  const plotH = h - margin.top - margin.bottom;
  
  // Find y range (Œ∏‚ÇÅ values)
  const yValues = coldSamples.map(s => s.x);
  const yMin = Math.min(...yValues, ymin);
  const yMax = Math.max(...yValues, ymax);
  
  // Draw grid
  ctx.strokeStyle = "#e2e8f0";
  ctx.lineWidth = 1;
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + i / 5 * plotH;
    ctx.beginPath();
    ctx.moveTo(margin.left, y);
    ctx.lineTo(margin.left + plotW, y);
    ctx.stroke();
  }
  
  // Draw trace
  ctx.strokeStyle = "#3b82f6";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  
  for (let i = 0; i < coldSamples.length; i++) {
    const x = margin.left + (i / (coldSamples.length - 1)) * plotW;
    const y = margin.top + (yMax - coldSamples[i].x) / (yMax - yMin) * plotH;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Axes
  ctx.strokeStyle = "#2d3748";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + plotH);
  ctx.lineTo(margin.left + plotW, margin.top + plotH);
  ctx.stroke();
  
  // Labels
  ctx.fillStyle = "#2d3748";
  ctx.font = "11px -apple-system, sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("Iteration", w / 2, h - 5);
  
  ctx.textAlign = "right";
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + i / 5 * plotH;
    const val = yMax - i / 5 * (yMax - yMin);
    ctx.fillText(val.toFixed(1), margin.left - 5, y + 3);
  }
  
  ctx.save();
  ctx.translate(12, margin.top + plotH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = "center";
  ctx.font = "bold 11px -apple-system, sans-serif";
  ctx.fillText("Œ∏‚ÇÅ", 0, 0);
  ctx.restore();
}

function drawBothCoordinates() {
  const ctx = bothCoordinatesCtx;
  const canvas = bothCoordinatesCanvas;
  const w = canvas.getBoundingClientRect().width;
  const h = canvas.getBoundingClientRect().height;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  if (coldSamples.length < 2) return;
  
  const margin = {top: 30, right: 80, bottom: 50, left: 60};
  const plotW = w - margin.left - margin.right;
  const plotH = h - margin.top - margin.bottom;
  
  // Find ranges
  const xValues = coldSamples.map(s => s.x);
  const yValues = coldSamples.map(s => s.y);
  const dataYMin = Math.min(...yValues, ymin);
  const dataYMax = Math.max(...yValues, ymax);
  
  // Draw grid
  ctx.strokeStyle = "#e2e8f0";
  ctx.lineWidth = 1;
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + i / 5 * plotH;
    ctx.beginPath();
    ctx.moveTo(margin.left, y);
    ctx.lineTo(margin.left + plotW, y);
    ctx.stroke();
  }
  
  // Draw horizontal line at 0 if in range
  if (dataYMin < 0 && dataYMax > 0) {
    const zeroY = margin.top + (dataYMax - 0) / (dataYMax - dataYMin) * plotH;
    ctx.strokeStyle = "#94a3b8";
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(margin.left, zeroY);
    ctx.lineTo(margin.left + plotW, zeroY);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  
  // Draw Œ∏‚ÇÅ trace (blue)
  ctx.strokeStyle = "#3b82f6";
  ctx.lineWidth = 2;
  ctx.beginPath();
  
  for (let i = 0; i < coldSamples.length; i++) {
    const x = margin.left + (i / (coldSamples.length - 1)) * plotW;
    const y = margin.top + (dataYMax - coldSamples[i].x) / (dataYMax - dataYMin) * plotH;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Draw Œ∏‚ÇÇ trace (orange)
  ctx.strokeStyle = "#f97316";
  ctx.lineWidth = 2;
  ctx.beginPath();
  
  for (let i = 0; i < coldSamples.length; i++) {
    const x = margin.left + (i / (coldSamples.length - 1)) * plotW;
    const y = margin.top + (dataYMax - coldSamples[i].y) / (dataYMax - dataYMin) * plotH;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Axes
  ctx.strokeStyle = "#2d3748";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + plotH);
  ctx.lineTo(margin.left + plotW, margin.top + plotH);
  ctx.stroke();
  
  // X-axis labels
  ctx.fillStyle = "#2d3748";
  ctx.font = "12px -apple-system, sans-serif";
  ctx.textAlign = "center";
  
  for (let i = 0; i <= 5; i++) {
    const x = margin.left + i / 5 * plotW;
    const iter = Math.round(i / 5 * (coldSamples.length - 1));
    ctx.fillText(iter, x, h - margin.bottom + 20);
  }
  
  ctx.font = "bold 13px -apple-system, sans-serif";
  ctx.fillText("Iteration", w / 2, h - 10);
  
  // Y-axis labels
  ctx.textAlign = "right";
  ctx.font = "12px -apple-system, sans-serif";
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + i / 5 * plotH;
    const val = dataYMax - i / 5 * (dataYMax - dataYMin);
    ctx.fillText(val.toFixed(1), margin.left - 8, y + 4);
  }
  
  ctx.save();
  ctx.translate(15, margin.top + plotH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = "center";
  ctx.font = "bold 13px -apple-system, sans-serif";
  ctx.fillText("Position", 0, 0);
  ctx.restore();
  
  // Legend
  ctx.textAlign = "left";
  ctx.font = "12px -apple-system, sans-serif";
  
  ctx.fillStyle = "#3b82f6";
  ctx.fillRect(w - margin.right + 10, margin.top + 10, 15, 3);
  ctx.fillStyle = "#2d3748";
  ctx.fillText("Œ∏‚ÇÅ", w - margin.right + 30, margin.top + 14);
  
  ctx.fillStyle = "#f97316";
  ctx.fillRect(w - margin.right + 10, margin.top + 30, 15, 3);
  ctx.fillStyle = "#2d3748";
  ctx.fillText("Œ∏‚ÇÇ", w - margin.right + 30, margin.top + 34);
}


function drawColdChain() {
  const ctx = coldChainCtx;
  const canvas = coldChainCanvas;
  
  // Get visual dimensions (what the user sees)
  const rect = canvas.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw background contour with proper normalization
  drawColdChainBackground(ctx, w, h);
  
  // Draw samples
  if (coldSamples.length > 0) {
    ctx.fillStyle = "rgba(220, 38, 38, 0.6)";
    for (const sample of coldSamples) {
      const cx = (sample.x - xmin) / (xmax - xmin) * w;
      const cy = (ymax - sample.y) / (ymax - ymin) * h;
      ctx.beginPath();
      ctx.arc(cx, cy, 2.5, 0, 2 * Math.PI);
      ctx.fill();
    }
  }
}

function drawColdChainBackground(ctx, w, h) {
  // First pass: find max Z for normalization
  let maxZ = 0;
  const step = 2;
  for (let j = 0; j < h; j += step) {
    for (let i = 0; i < w; i += step) {
      const x = xmin + (i / w) * (xmax - xmin);
      const y = ymax - (j / h) * (ymax - ymin);
      const z = target(x, y);
      if (z > maxZ) maxZ = z;
    }
  }
  
  // Second pass: draw with normalized colors
  for (let j = 0; j < h; j += step) {
    for (let i = 0; i < w; i += step) {
      const x = xmin + (i / w) * (xmax - xmin);
      const y = ymax - (j / h) * (ymax - ymin);
      const z = target(x, y);
      
      const normalized = maxZ > 0 ? z / maxZ : 0;
      const intensity = Math.floor(255 * (1 - normalized * 0.7));
      ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
      ctx.fillRect(i, j, step, step);
    }
  }
}

/***************************************************
 * STATS UPDATE
 ***************************************************/
function updateStats() {
  document.getElementById("totalIter").textContent = iteration.toLocaleString();
  document.getElementById("coldSamples").textContent = coldSamples.length.toLocaleString();
  
  const totalSwapAttempts = swapAttempts.reduce((a, b) => a + b, 0);
  const totalSwapAccepts = swapAccepts.reduce((a, b) => a + b, 0);
  
  document.getElementById("swapAttempts").textContent = totalSwapAttempts.toLocaleString();
  document.getElementById("swapAccepts").textContent = totalSwapAccepts.toLocaleString();
  
  if (iteration % swapFrequency === 0 && iteration > 0) {
    document.getElementById("stepInfo").textContent = 
      `Iteration ${iteration}: Performed replica exchange. Total swaps: ${totalSwapAccepts}/${totalSwapAttempts}`;
  } else {
    document.getElementById("stepInfo").textContent = 
      `Iteration ${iteration}: MCMC step. Next swap at iteration ${Math.ceil((iteration + 1) / swapFrequency) * swapFrequency}`;
  }
}

/***************************************************
 * INITIALIZATION
 ***************************************************/
setDomain();
reset();

</script>

</body>
</html>